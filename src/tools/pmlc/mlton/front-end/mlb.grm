(* mlb.grm
 *
 * COPYRIGHT (c) 2013 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * This code is based, in part, on the ml-yacc grammar in the MLton compiler, which is
 * Copyright (C) 2009 Matthew Fluet.
 * Copyright (C) 1999-2006 Henry Cejtin, Matthew Fluet, Suresh
 *    Jagannathan, and Stephen Weeks.
 * Copyright (C) 1997-2000 NEC Research Institute.
 *
 * MLton is released under a BSD-style license.
 * See the file MLton-LICENSE for details.
 *)

%name MLB;

%tokens
  : COMMA		(",")
  | SEMICOLON		(";")
  | AND			("and")
  | BAS			("bas")
  | BASIS		("basis")
  | END			("end")
  | EQUALOP		("=")
  | FUNCTOR		("functor")
  | IN			("in")
  | LET 		("let")
  | LOCAL		("local")
  | OPEN		("open")
  | SIGNATURE		("signature")
  | STRUCTURE		("structure")
  | ANN			("ann")
  | PRIM		("_prim")
  | ID of string
  | FILE of string
  | STRING of string
  ;

%defs (
fun reg (left, right) = let
    val map = SourceMap.getMap()
    val {fileName = file1, lineNo=lineNo1, colNo=colNo1} = AntlrStreamPos.sourceLoc map left
    val {fileName = file2, lineNo=lineNo2, colNo=colNo2} = AntlrStreamPos.sourceLoc map right
    val file1 = (case file1 of SOME x => x | NONE => "")
    val file2 = (case file2 of SOME x => x | NONE => "")
    in
      Region.make {
	  left = SourcePos.make{column=colNo1, file=file1, line=lineNo1},
	  right = SourcePos.make{column=colNo2, file=file2, line=lineNo2}
	}
    end
open Ast
);

%header (functor MLBParserFun (
	    structure Lex : ANTLR_LEXER
	    structure SourceMap : SOURCE_MAP
	    structure Ast: AST
	    val lexAndParseProgOrMLB: File.t * Region.t -> Ast.Basdec.node));

MLB	: BasDecs
	;

BasDecs	: BasDec (";"? BasDec)*
		=> (Basdec.makeRegion (Basdec.Seq(BasDec::SR), reg FULL_SPAN))
	;

BasDec
	: BasDecNode
		=> (Basdec.makeRegion (BasDecNode, reg FULL_SPAN))
	;

BasDecNode
	: "functor" FctBind ("and" FctBind)*
		=> (let 
		    val fctbinds = Vector.fromList(FctBind::SR)
		    in 
		      Basdec.Defs (ModIdBind.makeRegion (ModIdBind.Fct fctbinds, reg FULL_SPAN))
		    end)
	| "signature" SigBind ("and" SigBind)*
		=> (let
		    val sigbinds = Vector.fromList(SigBind::SR)
		    in
		      Basdec.Defs (ModIdBind.makeRegion (ModIdBind.Sig sigbinds, reg FULL_SPAN))
		    end)
	| "structure" StrBind ("and" StrBind)*
		=> (let
		    val strbinds = Vector.fromList(StrBind::SR)
		    in
		      Basdec.Defs (ModIdBind.makeRegion (ModIdBind.Str strbinds, reg FULL_SPAN))
		    end)
	| "basis" BasBind ("and" BasBind)*
		=> (let
		    val basbinds = Vector.fromList(BasBind::SR)
		    in
		      Basdec.Basis basbinds
		    end)
	| "local" BasDecs "in" BasDecs "end" 
		=> (Basdec.Local (BasDecs1, BasDecs2))
	| "open" BasId+
		=> (Basdec.Open (Vector.fromList BasId))
	| FILE
		=> (let
		    val reg = reg FULL_SPAN
		    in
		      lexAndParseProgOrMLB (FILE, reg)
		    end)
	| STRING
		=> (let
		    val reg = reg FULL_SPAN
		    in
		      lexAndParseProgOrMLB (STRING, reg)
		    end)
	| "_prim"
		=> (Basdec.Prim)
	| "ann" Ann+ "in" BasDecs "end"  
		=> (let 
		    val extendRight = let
			  val right = valOf (Region.right (Basdec.region BasDecs))
			  in
			    fn reg => Region.extendRight (reg, right)
			  end
		    fun mkAnn' ((ann, reg), basdecs) = Basdec.Ann (ann, reg, basdecs)
		    fun mkAnn ((ann, reg), basdecsnode) : Basdec.node =
			  mkAnn' ((ann, reg), Basdec.makeRegion (basdecsnode, extendRight reg))
		    val (anns, ann) = MLtonList.splitLast Ann
		    in
		      MLtonList.fold(anns, mkAnn'(ann, BasDecs), mkAnn)
		    end)
	;

FctBind
	: FctId ("=" FctId)?
		=> ({lhs = FctId, rhs = Option.getOpt(SR, FctId)})
	;

FctId	: Id	=> (Fctid.fromSymbol Id)
	;

SigBind
	: SigId ("=" SigId)?
		=> ({lhs = SigId, rhs = Option.getOpt(SR, SigId)})
	;

SigId	: Id	=> (Sigid.fromSymbol Id)
	;

StrBind
	: StrId ("=" StrId)?
		=> ({lhs = StrId, rhs = Option.getOpt(SR, StrId)})
	;

StrId	: Id	=> (Strid.fromSymbol Id)
	;

BasBind
	: BasId "=" BasExp
		=> ({name = BasId, def = BasExp})
	;

BasId	: Id	=> (Basid.fromSymbol Id)
	;

BasExp
	: "bas" BasDecs "end"
		=> (Basexp.makeRegion(Basexp.Bas BasDecs, reg FULL_SPAN))
	| BasId
		=> (Basexp.makeRegion(Basexp.Var BasId, reg FULL_SPAN))
	| "let" BasDecs "in" BasExp "end"
		=> (Basexp.makeRegion(Basexp.Let(BasDecs, BasExp), reg FULL_SPAN))
	;

Id	: ID	=> (Symbol.fromString ID, reg FULL_SPAN)
	;

Ann	: STRING
		=> (STRING, reg FULL_SPAN)
	;
