(* bom.grm
 *
 * COPYRIGHT (c) 2012 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *)

%name BOM;

%tokens
  : KW_alloc	("alloc")
(*  | KW_and	("and")       *)
  | KW_apply	("apply")
  | KW___attributes__ ("__attributes__")
(*  | KW_case	("case")    *)
  | KW_ccall	("ccall")		(* should use this! *)
  | KW_cont	("cont")
(*  | KW_datatype ("datatype")    *)
  | KW_define	("define")
(*  | KW_do	("do")        *)
(*  | KW_else	("else")    *)
(*  | KW_end    ("end")       *)
(*  | KW_exception ("exception") *)
  | KW_extern	("extern")
(*  | KW_fun	("fun")       *)
  | KW_host_vproc ("host_vproc")
(*  | KW_if     ("if")      *)
(*  | KW_let	("let")       *)
  | KW_noreturn	("noreturn")
  | KW_nullVP   ("nullVP")
(*  | KW_of     ("of")      *)
  | KW_promote  ("promote")
  | KW_return   ("return")
(*  | KW_then   ("then")    *)
  | KW_throw	("throw")
(*  | KW_type (	) *)
  | KW_typecase ("typecase")
  | KW_vpaddr   ("vpaddr")
  | KW_vpload   ("vpload")
  | KW_vpstore  ("vpstore")
(* BOM type identifiers *)
  | KW_addr	("addr")
  | KW_any	("any")
  | KW_array	("array")
  | KW_bignum	("bignum")
  | KW_exn	("exn")
  | KW_int8	("int8")
  | KW_int16	("int16")
  | KW_int32	("int32")
  | KW_int64	("int64")
  | KW_float32	("float32")
  | KW_float64	("float64")
  | KW_uint8	("uint8")
  | KW_uint16	("uint16")
  | KW_uint32	("uint32")
  | KW_uint64	("uint64")
  | KW_vector	("vector")
  | KW_void	("void")
  | KW_vproc	("vproc")
(* puntuation *)
(*  | LP    ("(")       *)
(*  | RP    (")")       *)
(*  | LB    ("[")       *)
(*  | RB    ("]")       *)
(*  | LCB     ("{")                   *)
(*  | RCB     ("}")                   *)
(*  | HASH    ("#")       *)
 (* | ASTERISK    ("*") *)
(*  | COMMA     (",")       *)
(*  | EQ    ("=")       *)
(*  | COLON     (":")       *)
(*  | SLASH     ("/")       *)
(*  | SEMI    (";")       *)
(*  | BAR     ("|")       *)
(*  | WILD    ("_")       *)
(*  | BANG    ("!")       *)
(*  | AMPERSAND     ("&")       *)
  | LT ("<")
  | GT (">")
(*  | ASSIGN  (":=")      *)
(*  | DARROW  ("=>")      *)
(*  | ARROW     ("->")      *)
(*  | LONGID of string       *)
  | HLID of string		(* "@"ID *)
  | LONG_HLID of string		(* qualified HLID *)
(*  | char of ... *)
(*  | INT of ... *)
(*  | REAL of FloatLit.float    *)
(*  | STRING of string      *)
  | ML_STRING of IntInf.int vector
  | PRIMOP of CharVector.vector
  ;

%defs(
  structure BOM = Ast.AstBOM

  fun optToList NONE = []
    | optToList (SOME xs) = xs

  fun flatten NONE = []
    | flatten (SOME(x, xs)) = x::xs

  fun optToEl (SOME x) = [x]
    | optToEl NONE = []

  fun makeId (regionMaker : ('a * Region.t) -> 'b,
        idFromSymbol : (Symbol.t * Region.t) -> 'a,
        s : string,
        thisSpan : Lex.pos * Lex.pos
      ) : 'b = let
	val thisRegion : Region.t = posToReg thisSpan
	val symbol = Symbol.fromString s
	in
	  regionMaker ((idFromSymbol (symbol, thisRegion)), thisRegion)
	end

  fun mkBomTy (ty, span) = BOM.BomType.makeRegion (ty, posToReg span)

  fun mkRawTy (rty, span) = (BOM.RawTy.makeRegion (rty, posToReg span))

  fun mkBomExp (exp, span) = BOM.Exp.makeRegion (exp, posToReg span)

  fun mkSimpleExp (exp, span) = BOM.SimpleExp.makeRegion (exp, posToReg span)

  fun intInfFromINT ({digits = ds, negate = isNeg, radix = rad}):IntInf.int =
    let
      val _ = print (String.concat ["parsing int. digits: ", ds, "\n"])
      val scanned = StringCvt.scanString (fn x => IntInf.scan rad x) ds
      val errorMsg = String.concat [
        "Something went wrong. Input ", ds, " isn't a number."
      ]
    in
      case scanned of
         NONE => raise Fail errorMsg
       | SOME(s) => s
   end

  local
    fun applyThunks (caseThunks, acc) =
      case caseThunks of
        thunk::[] => applyThunks ([], (thunk true)::acc)
      | [] => rev acc
      | thunk::thunks => applyThunks (thunks, (thunk false)::acc)

    fun assertDefaultLast (cases : 'a list,
        checkFn : 'a -> bool,
        thisSpan : AntlrStreamPos.pos * AntlrStreamPos.pos) : 'a list =
      if List.null cases then
        []
      else if (List.all checkFn (tl (rev cases))) then
        cases
      else
        ((error (posToReg thisSpan,
          "The default case can only come last"));
        [])

   in
     fun checkCaseRule (caseThunks,
         thisSpan : (AntlrStreamPos.pos * AntlrStreamPos.pos)) =
       assertDefaultLast (applyThunks (caseThunks, []),
         not o BOM.CaseRule.isDefault, thisSpan)
     fun checkTyCaseRule (cases,
         thisSpan : (AntlrStreamPos.pos * AntlrStreamPos.pos)) =
       assertDefaultLast (cases, not o BOM.TyCaseRule.isDefault, thisSpan)
   end

   fun longRuleThunk (longConId : BOM.LongConId.t,
       varPats: BOM.VarPat.t list,
       bomExp : BOM.Exp.t,
       thisSpan) : bool -> BOM.CaseRule.t =
     fn isLast : bool => BOM.CaseRule.makeRegion (BOM.CaseRule.LongRule (
       longConId, varPats, bomExp), posToReg thisSpan)

   fun literalRuleThunk (literal : BOM.Literal.t,
       bomExp : BOM.Exp.t,
       thisSpan) : bool -> BOM.CaseRule.t =
     fn isLast : bool => BOM.CaseRule.makeRegion (BOM.CaseRule.LiteralRule (
       literal, bomExp), posToReg thisSpan)

   fun defaultRuleThunk (varPat : BOM.VarPat.t,
       bomExp : BOM.Exp.t,
       thisSpan) : bool -> BOM.CaseRule.t =
     fn isLast : bool => BOM.CaseRule.makeRegion (BOM.CaseRule.DefaultRule (
       varPat, bomExp), posToReg thisSpan)

   fun longOrDefaultRuleThunk (id,
       bomExp : BOM.Exp.t,
       thisSpan) : bool -> BOM.CaseRule.t =
     fn isLast : bool => (if isLast then
       let
         val thisRegion = posToReg thisSpan
         val bomId = BOM.BomId.fromSymbol id (* (Symbol.fromString ID, thisRegion) *)
         val varPat = BOM.VarPat.makeRegion (BOM.VarPat.Var (bomId, NONE),
           thisRegion)
         val _ = print "longOrDefaultRuleThunk: emitting default\n" (* DEBUG *)
       in
         defaultRuleThunk(varPat, bomExp, thisSpan)(true)
       end
     else
       let
         val (singleId, idSpan) = id
         val longConId = BOM.LongConId.fromSymbols ([singleId], idSpan)
         val _ = print "longOrDefaultRuleThunk: emitting long\n" (* DEBUG *)
       in
         longRuleThunk(longConId, []: BOM.VarPat.t list, bomExp, thisSpan)(true)
       end)

);

BOMDecls
	: Definition*
		=> (Definition)
	;

Definition
	: "datatype" DatatypeDef ("and" DatatypeDef)* ";"
		=> (BOM.Definition.makeRegion (
		      BOM.Definition.Datatype(DatatypeDef::SR),
		      posToReg FULL_SPAN))
	| "type" BomId TyParams? "=" BOMType ";"
		=> (BOM.Definition.makeRegion (
		      BOM.Definition.TypeDefn (BomId, optToList TyParams, BOMType),
		      posToReg FULL_SPAN))
	| "exception" DataConsDef
		=> ()
	| "define" Attrs HLOpId TyParams? FunParams ReturnTy ("=" BOMExp)? ";"
		=> (BOM.Definition.makeRegion (let
		      val (inputTys, exnTys) = FunParams
		      in (
			BOM.Definition.DefineShortId (
			  SOME Attrs, HLOpId, optToList TyParams, inputTys, exnTys, ReturnTy, SR),
			posToReg FULL_SPAN
		      ) end))
	| "define" HLOpId TyParams? HLOpDef
	| "fun" FunDef ("and" FunDef)* ";"
	| "extern" CReturnTy BomId "(" (CArgTy ("," CArgTy)* => (CArgTy::SR))? ")" Attrs ";"
		=> (BOM.Definition.makeRegion (
		      BOM.Definition.Extern (CReturnTy, BomId, Option.getOpt (SR, []), Attrs),
		      posToReg FULL_SPAN))
	;

DatatypeDef
	: BomId TyParams? "=" DataConsDef ("|" DataConsDef)*
		=> (BOM.DataTypeDef.makeRegion (
		      BOM.DataTypeDef.ConsDefs (BomId, optToList TyParams, DataConsDef :: SR),
		      posToReg FULL_SPAN))
	;

DataConsDef
	: BomId ("of" BOMType)?
		=> (BOM.DataConsDef.makeRegion (
		      BOM.DataConsDef.ConsDef (BomId, SR),
		      posToReg FULL_SPAN))
	;

HLOpDef
	: FunParams ReturnTy ("=" BOMExp)? ";"
	| "=" BomLongId ";"
		=> (fn (hlOpId : BOM.HLOpId.t, tyParams, span) =>
		    (BOM.Definition.makeRegion (let
		      val (inputTys, exnTys) = FunParams
		      in
			(BOM.Definition.DefineShortId (
			  NONE, hlOpId, tyParams, inputTys, exnTys, ReturnTy, SR),
			posToReg span)
		      end)))
	;

(* 	| "define" Attrs HLOpId TyParams? FunParams ReturnTy ("=" BOMExp)? ";" *)
(* 		=> (BOM.Definition.makeRegion (let *)
(* 		      val (inputTys, exnTys) = FunParams *)
(* 		      in ( *)
(* 			BOM.Definition.DefineShortId ( *)
(* 			  SOME Attrs, HLOpId, optToList TyParams, inputTys, exnTys, ReturnTy, SR), *)
(* 			posToReg FULL_SPAN *)
(* 		      ) end)) *)
(* 	| "define" HLOpId TyParams? DefineRest *)
(* 		=> (DefineRest (HLOpId, optToList TyParams, FULL_SPAN)) *)
(* 	| "extern" CReturnTy BomId "(" (CArgTy ("," CArgTy)* => (CArgTy::SR))? ")" Attrs ";" *)
(* 		=> (BOM.Definition.makeRegion ( *)
(* 		      BOM.Definition.Extern (CReturnTy, BomId, Option.getOpt (SR, []), Attrs), *)
(* 		      posToReg FULL_SPAN)) *)
(* 	| "fun" FunDef ("and" FunDef)* ";" *)
(* 		=> (BOM.Definition.makeRegion ( *)
(* 		    BOM.Definition.Fun (FunDef::SR), *)
(* 		    posToReg FULL_SPAN)) *)
(* (* FIXME: need to add exception definition *) *)
(* 	; *)

(* FIXME: this can be made to work better with DefineShortId above *)
DefineRest
	: FunParams ReturnTy ("=" BOMExp)? ";"
		=> (fn (hlOpId : BOM.HLOpId.t, tyParams, span) =>
      (BOM.Definition.makeRegion (
        let
          val (inputTys, exnTys) = FunParams
        in
          (BOM.Definition.DefineShortId (
            NONE, hlOpId, tyParams, inputTys, exnTys, ReturnTy, SR),
          posToReg span)
        end)))
	| "=" LongValueId ";"
     => (fn (hlOpId, tyParams, span) =>
           BOM.Definition.makeRegion (
             BOM.Definition.DefineLongId (hlOpId, tyParams, LongValueId),
             posToReg FULL_SPAN))
	;


TyParams
	: "<" TyParam ("," TyParam)* ">"
		=> (TyParam::SR)
	;

TyArgs
	: "<" BOMType ("," BOMType)* ">"
		=> (BOMType::SR)
	;


RangeTy
  : BOMType
    => ([BOMType])
  | "(" BOMType ("," BOMType)* ")"
    => (BOMType::SR)
  ;

TypeList
  : (* empty *)
    => ([])
  | RangeTy
  ;

(* ReturnTy *)
(*   : "noreturn" *)
(*     => ([]) *)
(*   | "->" RangeTy *)
(*   ; *)


ReturnTy
	: "noreturn"
		=> ([])
	| "->" BOMType
		=> ([BOMType])
	| "->" "(" BOMType ("," BOMType)* ")"
		=> (BOMType::SR)
	;

BOMType
	: TyParam
		=> (mkBomTy (BOM.BomType.Param TyParam, FULL_SPAN))
	| LongTyId TyArgs?
		=> (mkBomTy (BOM.BomType.LongId(LongTyId, optToList TyArgs), FULL_SPAN))
	| "{" FieldTy ("," FieldTy)* "}"
		=> (mkBomTy (BOM.BomType.Record(FieldTy::SR), FULL_SPAN))
	|  "[" TupleFieldTy ("," TupleFieldTy)* "]"
		=> (mkBomTy (BOM.BomType.Tuple(TupleFieldTy::SR), FULL_SPAN))
	| "fun" "(" TypeList "/" TypeList "->" RangeTy ")"
		=> (mkBomTy (BOM.BomType.Fun(TypeList1, TypeList2, RangeTy), FULL_SPAN))
	| "cont" TyArgs?
		=> (mkBomTy (BOM.BomType.Cont(optToList TyArgs), FULL_SPAN))
	| "array" "<" BOMType ">"
		=> (mkBomTy (BOM.BomType.Array BOMType, FULL_SPAN))
	| "vector" "<" BOMType ">"
		=> (mkBomTy (BOM.BomType.Vector BOMType, FULL_SPAN))
	| "addr" "<" BOMType ">"
		=> (mkBomTy (BOM.BomType.Addr BOMType, FULL_SPAN))
	| "bignum"
		=> (mkBomTy (BOM.BomType.BigNum, FULL_SPAN))
	| "exn"
		=> (mkBomTy (BOM.BomType.Exn, FULL_SPAN))
	| "any"
		=> (mkBomTy (BOM.BomType.Any, FULL_SPAN))
	| "vproc"
		=> (mkBomTy (BOM.BomType.VProc, FULL_SPAN))
	| RawTy
		=> (mkBomTy (BOM.BomType.Raw RawTy, FULL_SPAN))
	;

FieldTy
	: PosInt ":" BOMType
		=> (BOM.Field.makeRegion (
		      BOM.Field.Immutable (PosInt, BOMType),
		      posToReg FULL_SPAN))
	| PosInt "!" BOMType
		=> (BOM.Field.makeRegion (
		      BOM.Field.Mutable (PosInt, BOMType),
		      posToReg FULL_SPAN))
	;

PosInt
	: INT
		=> (if #negate INT
		      then (
			(error (posToReg FULL_SPAN, "Value must be positive"));
			IntInf.fromInt 0)
		      else intInfFromINT INT)
	;

TupleFieldTy
	: "!" BOMType	=> (true, BOMType)
	| BOMType	=> (false, BOMType)
	;

(* TypeList *)
(* 	: (* empty *) *)
(* 		=> [] *)
(* 	| BOMType ("," BOMType)* *)
(* 		=> (BOMType::SR1) *)
(* 	; *)

(* RangeTy *)
(* 	: TypeList *)
(* 		=> (TypeList) *)
(* 	| "noreturn" *)
(* 		=> ([])		(* FIXME: need an explicit representation here *) *)
(* 	; *)

FunDef
	: Attrs? BomId TyParams? "(" Params? ("/" Params)? ")" ReturnTy "=" BOMExp
		=> (BOM.FunDef.makeRegion (
		      BOM.FunDef.Def (Attrs, BomId, optToList TyParams, optToList Params,
		      optToList SR, ReturnTy, BOMExp), posToReg FULL_SPAN))
	;

Attrs
	: "__attributes__" "(" string ("," string)* ")"
		=> (BOM.Attrs.makeRegion (
		      BOM.Attrs.T (string::SR),
		      posToReg FULL_SPAN))
	;

BOMExp
	: "let" VarPat ("," VarPat)* "=" RHS BOMExp
		=> (mkBomExp (BOM.Exp.Let (VarPat::SR, RHS, BOMExp), FULL_SPAN))
	| "do" SimpleExp BOMExp
		=> (mkBomExp (BOM.Exp.Do (SimpleExp, BOMExp), FULL_SPAN))
	| "fun" FunDef ("and" FunDef)* BOMExp
		=> (mkBomExp (BOM.Exp.FunExp (FunDef::SR, BOMExp), FULL_SPAN))
	| "cont" BomId "(" Params? ")" "=" BOMExp BOMExp
		=> (mkBomExp (BOM.Exp.ContExp (BomId, optToList Params, BOMExp1, BOMExp2), FULL_SPAN))
	| "if" SimpleExp "then" BOMExp "else" BOMExp
		=> (mkBomExp (BOM.Exp.If (SimpleExp, BOMExp1, BOMExp2), FULL_SPAN))
	| "case" SimpleExp "of" CaseRule ("|" CaseRule)*  "end"
		=> (mkBomExp (
		      BOM.Exp.Case (SimpleExp, checkCaseRule (CaseRule::SR, FULL_SPAN)),
		      FULL_SPAN))
	| "typecase" TyParam "of" TyCaseRule ("|" TyCaseRule)* "end"
		=> (mkBomExp (
		      BOM.Exp.Typecase (TyParam, TyCaseRule::(checkTyCaseRule (SR, posToReg FULL_SPAN))),
		      FULL_SPAN))
	| "apply" LongValueId "(" Args? ("/" Args)? ")"
		=> (mkBomExp (BOM.Exp.Apply (LongValueId, optToList Args, optToList SR), FULL_SPAN))
	| "throw" BomId "(" Args? ")"
		=> (mkBomExp (BOM.Exp.Throw (BomId, optToList Args), FULL_SPAN))
	| "return" "(" Args? ")"
		=> (mkBomExp (BOM.Exp.Return (optToList Args), FULL_SPAN))
	;

Args
	: SimpleExp ("," SimpleExp)*
		=> (SimpleExp::SR)
	;


RHS
	: BOMExp
		=> (BOM.RHS.makeRegion (BOM.RHS.Composite BOMExp, posToReg FULL_SPAN))
	| SimpleExp
		=> (BOM.RHS.makeRegion (BOM.RHS.Simple SimpleExp, posToReg FULL_SPAN))
	;


PrimOp
	: ID => (BOM.PrimOp.fromSymbol ID)
	;

SimpleExp
	: PrimOp "(" Args ")"
		=> (mkSimpleExp (BOM.SimpleExp.PrimOp (PrimOp, Args), FULL_SPAN))
	| "alloc" LongValueId "(" Args ")"
		=> (mkSimpleExp (BOM.SimpleExp.AllocId (LongValueId, Args), FULL_SPAN))
	| "alloc" TyArgs "(" Args ")"
		=> (mkSimpleExp (BOM.SimpleExp.AllocType (TyArgs, Args), FULL_SPAN))
	| "#" PosInt "(" SimpleExp ")" (":=" SimpleExp)?
		=> (mkSimpleExp (BOM.SimpleExp.AtIndex (PosInt, SimpleExp, SR), FULL_SPAN))
	| "(" BOMType ")" SimpleExp
		=> (mkSimpleExp (BOM.SimpleExp.TypeCast (BOMType, SimpleExp), FULL_SPAN))
	| "promote" "(" SimpleExp ")"
		=> (mkSimpleExp (BOM.SimpleExp.Promote SimpleExp, FULL_SPAN))
	| "host_vproc"
		=> (mkSimpleExp (BOM.SimpleExp.HostVproc, FULL_SPAN))
(* FIXME: use symbolic names/strings for offsets in vpload, etc. *)
	| "vpload" "(" PosInt "," SimpleExp ")"
		=> (mkSimpleExp (BOM.SimpleExp.VpLoad (PosInt, SimpleExp), FULL_SPAN))
	| "vpaddr" "(" PosInt "," SimpleExp ")"
		=> (mkSimpleExp (BOM.SimpleExp.VpAddr (PosInt, SimpleExp), FULL_SPAN))
	| "vpstore" "(" PosInt "," SimpleExp "," SimpleExp ")"
		=> (mkSimpleExp (BOM.SimpleExp.VpStore (PosInt, SimpleExp1, SimpleExp2), FULL_SPAN))
	| LongValueId
		=> (mkSimpleExp (BOM.SimpleExp.Id BOMLongId, FULL_SPAN))
	| Literal
		=> (mkSimpleExp (BOM.SimpleExp.Lit Literal, FULL_SPAN))
	| ML_STRING
		=> (mkSimpleExp (BOM.SimpleExp.MLString ML_STRING, FULL_SPAN))
	;

(* We don't keep track of quite the right regions here *)
CaseRule
	(* : BOMPat "=>" BOMExp *)
	(* 	=> () *)
	(* ; *)

	: longid ( "(" VarPat ("," VarPat)* ")" )? "=>" BOMExp
      => (longRuleThunk (
        BOM.LongConId.fromSymbols longid,
        flatten SR,
        BOMExp,
        FULL_SPAN))
	| Literal "=>" BOMExp
      => (literalRuleThunk (Literal, BOMExp, FULL_SPAN))
	(* | idForLongid "(" VarPat ("," VarPat)* ")" "=>" BOMExp *)
  (*     => (longRuleThunk ( *)
  (*       BOM.LongConId.fromSymbols idForLongid, *)
  (*       VarPat::SR, *)
  (*       BOMExp, *)
  (*       FULL_SPAN)) *)
	| BomId ":" BOMType "=>" BOMExp
      => (defaultRuleThunk (BOM.VarPat.makeRegion (BOM.VarPat.Var (
        BomId, SOME BOMType), posToReg FULL_SPAN), BOMExp, FULL_SPAN))
  | "_" (":" BOMType)? "=>" BOMExp
      => (defaultRuleThunk (BOM.VarPat.makeRegion (BOM.VarPat.Wild SR,
        posToReg FULL_SPAN), BOMExp, FULL_SPAN))
  | ID "=>" BOMExp
      => (longOrDefaultRuleThunk ((Symbol.fromString ID, posToReg FULL_SPAN),
        BOMExp, FULL_SPAN))
	;

BOMPat
	: LONGID ( "(" VarPat ("," VarPat)* ")" )?
	| ID "(" VarPat ("," VarPat)* ")"
	| ID ":" BOMType
	| ID
	| Literal
	| "_" (":" BOMType)?
	;

VarPat
	: BomId (":" BOMType)?
		=> (BOM.VarPat.makeRegion (
		      BOM.VarPat.Var (BomId, SR),
		      posToReg FULL_SPAN))
	| "_" (":" BOMType)?
		=> (BOM.VarPat.makeRegion (BOM.VarPat.Wild SR, posToReg FULL_SPAN))
	;

TyCaseRule
	: BOMType "=>" BOMExp
		=> (BOM.TyCaseRule.makeRegion (
		      BOM.TyCaseRule.TyRule (BOMType, BOMExp),
		      posToReg FULL_SPAN))
	| "_" "=>" BOMExp
		=> (BOM.TyCaseRule.makeRegion (
		      BOM.TyCaseRule.Default BOMExp,
		      posToReg FULL_SPAN))
	;

Literal
	: INT
		=> (let
		    val myInt = intInfFromINT INT
		    val sign = if (#negate INT) then ~1 else 1
		    in
		      BOM.Literal.makeRegion (
		        BOM.Literal.PosInt (IntInf.* (myInt, sign)),
			posToReg FULL_SPAN)
		    end)
	| REAL
		=> (BOM.Literal.makeRegion (
		    BOM.Literal.Float (Option.valOf (Real.fromString REAL)),
		    posToReg FULL_SPAN))
	| string
		=> (BOM.Literal.makeRegion (BOM.Literal.String string, posToReg FULL_SPAN))
	| "nullVP"
		=> (BOM.Literal.makeRegion (BOM.Literal.NullVP, posToReg FULL_SPAN))
	;


CReturnTy
	: "void"
		=> (BOM.CReturnTy.makeRegion (BOM.CReturnTy.Void, posToReg FULL_SPAN))
	| CArgTy
		=> (BOM.CReturnTy.makeRegion (
			BOM.CReturnTy.CArg CArgTy,
			posToReg FULL_SPAN))
	;

CArgTy
	: RawTy
		=> (BOM.CArgTy.makeRegion (BOM.CArgTy.Raw RawTy, posToReg FULL_SPAN))
	| "void" "*"
		=> (BOM.CArgTy.makeRegion (BOM.CArgTy.VoidPointer, posToReg FULL_SPAN))
	;

RawTy
	: "int8"	=> (mkRawTy (BOM.RawTy.Int8, FULL_SPAN))
	| "uint8"	=> (mkRawTy (BOM.RawTy.Uint8, FULL_SPAN))
	| "int16"	=> (mkRawTy (BOM.RawTy.Int16, FULL_SPAN))
	| "uint16"	=> (mkRawTy (BOM.RawTy.Uint16, FULL_SPAN))
	| "int32"	=> (mkRawTy (BOM.RawTy.Int32, FULL_SPAN))
	| "uint32"	=> (mkRawTy (BOM.RawTy.Uint32, FULL_SPAN))
	| "int64"	=> (mkRawTy (BOM.RawTy.Int64, FULL_SPAN))
	| "uint64"	=> (mkRawTy (BOM.RawTy.Uint64, FULL_SPAN))
	| "float32"	=> (mkRawTy (BOM.RawTy.Float32, FULL_SPAN))
	| "float64"	=> (mkRawTy (BOM.RawTy.Float64, FULL_SPAN))
	;



FunParams
	: "(" Params? (")" => ([]) | "/" Params ")" => (Params))
		=> (Option.getOpt (Params, []), SR)
	;

Params
	: VarPat ("," VarPat)*
		=> (VarPat::SR)
	;

(***** Identifiers *****)

BomId	: ID
		=> (BOM.BomId.fromSymbol (Symbol.fromString ID, posToReg FULL_SPAN))
	;

BomLongId
	: ID
		=> (BOM.LongTyId.fromSymbols ([Symbol.fromString ID], posToReg FULL_SPAN))
	| LONGID
		=> (let
		    val syms = List.map Symbol.fromString (split (LONGID, #"."))
		    in
		      BOM.LongTyId.fromSymbols (syms, posToReg FULL_SPAN)
		    end)
	;

(* FIXME: temporary change so it compiles *)
idForLongId
  : ID
    => ([Symbol.fromString ID], posToReg FULL_SPAN)
  | LONGID
    => (List.map Symbol.fromString (split (LONGID, #".")), posToReg FULL_SPAN)
  ;

LongValueId
  : idForLongId
    => (BOM.LongValueId.fromSymbols idForLongId)
  ;

LongTyId
  : idForLongId
    => (BOM.LongTyId.fromSymbols idForLongId)
  ;

HLOpId
	: HLID
		=> (BOM.HLOpId.fromSymbol(Symbol.fromString HLID, posToReg FULL_SPAN))
	;

HLOpQId
	: HLID
		=> (BOM.HLOpQId.fromSymbols ([Symbol.fromString HLID], posToReg FULL_SPAN))
	| LONG_HLID
		=> (BOM.HLOpQId.fromSymbols (
		      List.map Symbol.fromString (split(LONG_HLID, #".")),
		      posToReg FULL_SPAN))
	;

TyParam
	: TYVAR
		=> (BOM.TyParam.fromSymbol (Symbol.fromString TYVAR, posToReg FULL_SPAN))
	;
