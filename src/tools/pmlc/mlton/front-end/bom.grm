(* bom.grm
 *
 * COPYRIGHT (c) 2012 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *)

%name BOM;

%tokens
  : KW_addr   ("addr")
  | KW_alloc  ("alloc")
(*  | KW_and  ("and")       *)
  | KW_any  ("any")
  | KW_apply  ("apply")
  | KW___attributes__ ("__attributes__")
(*  | KW_case   ("case")    *)
  | KW_ccall  ("ccall")		(* should use this! *)
  | KW_cont   ("cont")
(*  | KW_datatype   ("datatype")    *)
  | KW_define   ("define")
(*  | KW_do     ("do")        *)
(*  | KW_else   ("else")    *)
(*  | KW_end  ("end")       *)
  | KW_extern   ("extern")
(*  | KW_fun  ("fun")       *)
  | KW_host_vproc ("host_vproc")
(*  | KW_if     ("if")      *)
  | KW_inline   ("inline")		(* maybe we should use this! *)
  | KW_instance ("instance")
  | KW_int  ("int")
(*  | KW_let  ("let")       *)
  | KW_noreturn   ("noreturn")
  | KW_nullVP   ("nullVP")
(*  | KW_of     ("of")      *)
  | KW_promote  ("promote")		(* should use this! *)
  | KW_return   ("return")
(*  | KW_then   ("then")    *)
  | KW_throw  ("throw")
(*  | KW_type ("type") *)
  | KW_typecase ("typecase")
  | KW_void   ("void")
  | KW_vpaddr   ("vpaddr")
  | KW_vproc  ("vproc")
  | KW_vpload   ("vpload")
  | KW_vpstore  ("vpstore")
(* All of the new RawTy identifiers *)
  | KW_int8 ("int8")
  | KW_uint8 ("uint8")
  | KW_int16 ("int16")
  | KW_int32 ("int32")
  | KW_uint32 ("uint32")
  | KW_uint16 ("uint16")
  | KW_int64 ("int64")
  | KW_uint64 ("uint64")
  | KW_float32 ("float32")
  | KW_float64 ("float64")
(*  | LP    ("(")       *)
(*  | RP    (")")       *)
(*  | LB    ("[")       *)
(*  | RB    ("]")       *)
(*      | LCB     ("{")                   *)
(*      | RCB     ("}")                   *)
(*  | HASH    ("#")       *)
 (* | ASTERISK    ("*") *)
(*  | COMMA     (",")       *)
(*  | EQ    ("=")       *)
(*  | COLON     (":")       *)
(*  | SLASH     ("/")       *)
(*  | SEMI    (";")       *)
(*  | BAR     ("|")       *)
(*  | WILD    ("_")       *)
(*  | BANG    ("!")       *)
(*  | AMPERSAND     ("&")       *)
  | LT ("<")
  | GT (">")
(*  | ASSIGN  (":=")      *)
(*  | DARROW  ("=>")      *)
(*  | ARROW     ("->")      *)
    | DDARROW       ("==>")
(*  | LONGID of string       *)
  | HLID of string		(* "@"ID *)
  | LONG_HLID of string		(* qualified HLID *)
(*  | char of ... *)
(*  | INT of ... *)
(*  | REAL of FloatLit.float    *)
(*  | STRING of string      *)
  | ML_STRING of IntInf.int vector
  | PRIMOP of CharVector.vector
  ;

%defs(
  structure BOM = Ast.AstBOM

  fun optToList maybe =
    Option.getOpt (maybe, [])

  fun flatten maybe =
    case maybe of
      NONE => []
    | SOME(x, xs) => x::xs

  fun optToEl maybe =
    if Option.isSome maybe then
      [Option.valOf maybe]
    else
      []

  fun makeId (regionMaker : ('a * Region.t) -> 'b,
        idFromSymbol : (Symbol.t * Region.t) -> 'a,
        s : string,
        thisSpan : Lex.pos * Lex.pos) : 'b =
    let
      val thisRegion : Region.t = posToReg thisSpan
      val symbol = Symbol.fromString s
    in
      regionMaker ((idFromSymbol (symbol, thisRegion)), thisRegion)
    end

  fun splitLongIdString (id : CharVector.vector) =
    let
      fun doSplit (toSplit, elAcc, listAcc) =
        case (toSplit, elAcc) of
          (#"."::cs, elAcc) =>
            doSplit (cs, [], elAcc::listAcc)
        | (c::cs, elAcc) =>
            doSplit (cs, c::elAcc, listAcc)
        | ([], []) =>
            listAcc
        | ([], elAcc) =>
            elAcc::listAcc
   in
     map String.implode (doSplit ((explode id), [], []))
   end

  fun makeLongId (longIdFromSymbols : (Symbol.t list * Region.t) -> 'a,
        s : string, thisSpan : Lex.pos * Lex.pos) : 'a =
    longIdFromSymbols (
      map Symbol.fromString (splitLongIdString s), posToReg thisSpan)

  fun intInfFromINT ({digits = ds, negate = isNeg, radix = rad}):IntInf.int =
    let
      val _ = print (String.concat ["parsing int. digits: ", ds, "\n"])
      val scanned = StringCvt.scanString (fn x => IntInf.scan rad x) ds
      val errorMsg = String.concat [
        "Something went wrong. Input ", ds, " isn't a number."
      ]
    in
      case scanned of
         NONE => raise Fail errorMsg
       | SOME(s) => s
   end

  local
    (* fun checkCaseRuleFn (c : BOM.CaseRule.t) : bool = *)
    (*   case Region.Wrap.node c of *)
    (*     BOM.CaseRule.CaseDefault c => false *)
    (*   | _ => true *)

    (* fun checkTyCaseRuleFn (c : BOM.TyCaseRule.t) : bool = *)

    fun applyThunks (caseThunks, acc) =
      case caseThunks of
        thunk::[] => applyThunks ([], (thunk true)::acc)
      | [] => rev acc
      | thunk::thunks => applyThunks (thunks, (thunk false)::acc)


    fun assertDefaultLast (cases : 'a list,
        checkFn : 'a -> bool,
        thisSpan : AntlrStreamPos.pos * AntlrStreamPos.pos) : 'a list =
      if List.null cases then
        []
      else if (List.all checkFn (tl (rev cases))) then
        cases
      else
        ((error (posToReg thisSpan,
          "The default case can only come last"));
        [])

   in
     fun checkCaseRule (caseThunks,
         thisSpan : (AntlrStreamPos.pos * AntlrStreamPos.pos)) =
       assertDefaultLast (applyThunks (caseThunks, []),
         not o BOM.CaseRule.isDefault, thisSpan)
     fun checkTyCaseRule (cases,
         thisSpan : (AntlrStreamPos.pos * AntlrStreamPos.pos)) =
       assertDefaultLast (cases, not o BOM.TyCaseRule.isDefault, thisSpan)
   end

   fun longRuleThunk(longConId : BOM.LongConId.t,
       varPats: BOM.VarPat.t list,
       bomExp : BOM.Exp.t,
       thisSpan) : bool -> BOM.CaseRule.t =
     fn isLast : bool => BOM.CaseRule.makeRegion (BOM.CaseRule.LongRule (
       longConId, varPats, bomExp), posToReg thisSpan)

   fun literalRuleThunk(literal : BOM.Literal.t,
       bomExp : BOM.Exp.t,
       thisSpan) : bool -> BOM.CaseRule.t =
     fn isLast : bool => BOM.CaseRule.makeRegion (BOM.CaseRule.LiteralRule (
       literal, bomExp), posToReg thisSpan)

   fun defaultRuleThunk(varPat : BOM.VarPat.t,
       bomExp : BOM.Exp.t,
       thisSpan) : bool -> BOM.CaseRule.t =
     fn isLast : bool => BOM.CaseRule.makeRegion (BOM.CaseRule.DefaultRule (
       varPat, bomExp), posToReg thisSpan)

   (* fun defaultRuleWildThunk (bomExp : BOM.Exp.t,  *)
   (*     maybeBOMType : BOM.BomType.t option, *)
   (*     thisSpan) : bool -> BOM.CaseRule.t =  *)
   (*   fn isLast : bool => BOM.CaseRule.makeRegion (BOM.caseRule.defaultRule  *)

   fun longOrDefaultRuleThunk(id,
       bomExp : BOM.Exp.t,
       thisSpan) : bool -> BOM.CaseRule.t =
     fn isLast : bool => (if isLast then
       let
         val thisRegion = posToReg thisSpan
         val bomId = BOM.BomId.fromSymbol id (* (Symbol.fromString ID, thisRegion) *)
         val varPat = BOM.VarPat.makeRegion (BOM.VarPat.Var (bomId, NONE),
           thisRegion)
         val _ = print "longOrDefaultRuleThunk: emitting default\n" (* DEBUG *)
       in
         defaultRuleThunk(varPat, bomExp, thisSpan)(true)
       end
     else
       let
         val (singleId, idSpan) = id
         val longConId = BOM.LongConId.fromSymbols ([singleId], idSpan)
         val _ = print "longOrDefaultRuleThunk: emitting long\n" (* DEBUG *)
       in
         longRuleThunk(longConId, []: BOM.VarPat.t list, bomExp, thisSpan)(true)
       end)

);

BOMDecls
  : Definition*
    => (Definition)
  ;

Definition
	(* : "datatype" DataTypeDef ("and" DataTypeDef)* ";" *)
	(* 	=> (BOM.Definition.makeRegion ( *)
	(* 	      BOM.Definition.Datatype (DataTypeDef::SR), *)
	(* 	      posToReg FULL_SPAN)) *)
  : "datatype" BomId TyParams? "=" (
      DataTypeDefRHS ("and" DataTypeDef)*
        => (BOM.Definition.makeRegion (
          BOM.Definition.Datatype ((DataTypeDefRHS (
            BomId, TyParams, FULL_SPAN)::SR)),
          posToReg FULL_SPAN))
      | "datatype" LongTyId
      => (BOM.Definition.makeRegion (
          BOM.Definition.DatatypeAlias (BomId, TyParams, LongTyId),
          posToReg FULL_SPAN))) ";" => (SR)
	| "type" BomId TyParams? "=" BOMType ";"
		=> (BOM.Definition.makeRegion (
		      BOM.Definition.TypeDefn (BomId, TyParams, BOMType),
		      posToReg FULL_SPAN))
	| "define" Attrs HLOpId TyParams? FunParams ReturnTy ("=" BOMExp)? ";"
		=> (BOM.Definition.makeRegion (let
		      val (inputTys, exnTys) = FunParams
		      in (
			BOM.Definition.DefineShortId (
			  SOME Attrs, HLOpId, TyParams, inputTys, exnTys, ReturnTy, SR),
			posToReg FULL_SPAN
		      ) end))
	| "define" HLOpId TyParams? DefineRest
		=> (DefineRest (HLOpId, TyParams, FULL_SPAN))
	| "extern" CReturnTy BomId "(" (CArgTy ("," CArgTy)* => (CArgTy::SR))? ")" Attrs ";"
		=> (BOM.Definition.makeRegion (
		      BOM.Definition.Extern (CReturnTy, BomId, Option.getOpt (SR, []), Attrs),
		      posToReg FULL_SPAN))
	| "fun" FunDef ("and" FunDef)* ";"
		=> (BOM.Definition.makeRegion (
		    BOM.Definition.Fun (FunDef::SR),
		    posToReg FULL_SPAN))
	| "instance" "type" LongTyId TyArgs ";"
		=> (BOM.Definition.makeRegion (
		      BOM.Definition.InstanceType (LongTyId, TyArgs),
		      posToReg FULL_SPAN))
	| "instance" LongValueId TyArgs ";"
		=> (BOM.Definition.makeRegion (
		      BOM.Definition.Instance (LongValueId, TyArgs),
		      posToReg FULL_SPAN))
	;

(* FIXME: this can be made to work better with DefineShortId above *)
DefineRest
	: FunParams ReturnTy ("=" BOMExp)? ";"
		=> (fn (hlOpId : BOM.HLOpId.t, tyParams : BOM.TyParams.t option, span) =>
      (BOM.Definition.makeRegion (
        let
          val (inputTys, exnTys) = FunParams
        in
          (BOM.Definition.DefineShortId (
            NONE, hlOpId, tyParams, inputTys, exnTys, ReturnTy, SR),
          posToReg span)
        end)))
	| "=" LongValueId ";"
     => (fn (hlOpId, tyParams, span) =>
           BOM.Definition.makeRegion (
             BOM.Definition.DefineLongId (hlOpId, tyParams, LongValueId),
             posToReg FULL_SPAN))
	;

DataTypeDefRHS
  : DataConsDef ("|" DataConsDef)*
   => (fn (bomId, tyParams, thisSpan) =>
     BOM.DataTypeDef.makeRegion (
       BOM.DataTypeDef.ConsDefs (bomId, tyParams, DataConsDef::SR),
       posToReg thisSpan))
  ;

DataTypeDef
  (* : BomId TyParams? "=" DataConsDef ("|" DataConsDef)* *)
  (*     => (BOM.DataTypeDef.makeRegion ( *)
  (*       BOM.DataTypeDef.ConsDefs (BomId, TyParams, DataConsDef::SR), *)
  (*       posToReg FULL_SPAN)) *)
  : BomId TyParams? "=" DataTypeDefRHS
      => (DataTypeDefRHS (BomId, TyParams, FULL_SPAN))
  ;

(* DataTypeDef *)
(*   : BomId TyParams? "=" "datatype" LongTyId *)
(*   (* | BomId TyParams? "=" "datatype" LongTyId *) *)
(*         => (BOM.DataTypeDef.makeRegion *)
(*              (BOM.DataTypeDef.SimpleDef (BomId, TyParams, LongTyId), *)
(*             posToReg FULL_SPAN)) *)
  (* ; *)

DataConsDef
  : BomId ("of" BOMType)?
    => (BOM.DataConsDef.makeRegion
      (BOM.DataConsDef.ConsDef (BomId, SR),
      posToReg FULL_SPAN))
  ;

TyParams
  : "<" TyParam ("," TyParam)* ">"
    => (BOM.TyParams.makeRegion (
      BOM.TyParams.T (TyParam::SR),
      posToReg FULL_SPAN))
  ;

TyArgs
  : "<" BOMType ("," BOMType)* ">"
    => (BOM.TyArgs.makeRegion (
      BOM.TyArgs.ArgTypes (BOMType::SR),
      posToReg FULL_SPAN))
  ;

(* We need to do this because the "id" nonterminal in ml.grm is
actually a LONGID that's been forced to be nonqualified. ID does not
match LONGID in BOM now, so it fails. *)
shortId
  : ID => (Symbol.fromString ID, posToReg FULL_SPAN)
  ;

idForLongid
  : ID => ([Symbol.fromString ID], posToReg FULL_SPAN)
  ;

BomId
	: shortId => (BOM.BomId.fromSymbol shortId)
	;

HLOpId
	: HLID => (BOM.HLOpId.fromSymbol(Symbol.fromString HLID, posToReg FULL_SPAN))
	;

HLOpQId
	: HLID
      => (BOM.HLOpQId.fromSymbols (
        [Symbol.fromString HLID], posToReg FULL_SPAN))
	| LONG_HLID
      => (BOM.HLOpQId.fromSymbols (
       map Symbol.fromString (splitLongIdString LONG_HLID),
       posToReg FULL_SPAN))
	;

TyParam
  : TYVAR
      => (BOM.TyParam.fromSymbol (Symbol.fromString TYVAR, posToReg FULL_SPAN))
  ;

LongTyId
  : longid => (BOM.LongTyId.fromSymbols longid)
  | idForLongid => (BOM.LongTyId.fromSymbols idForLongid)
  ;

LongConId
  : longid => (BOM.LongConId.fromSymbols longid)
  | idForLongid => (BOM.LongConId.fromSymbols idForLongid)
  ;

LongValueId
	: longid => (BOM.LongValueId.fromSymbols longid)
	| idForLongid => (BOM.LongValueId.fromSymbols idForLongid)
	;

BOMType
  : TyParam
      => (BOM.BomType.makeRegion (
        BOM.BomType.Param TyParam,
        posToReg FULL_SPAN))
  | LongTyId TyArgs?
      => (BOM.BomType.makeRegion (
        BOM.BomType.LongId (LongTyId, TyArgs),
        posToReg FULL_SPAN))
  | "{" Field ("," Field)* "}"
      => (BOM.BomType.makeRegion (
        BOM.BomType.Record (Field::SR),
        posToReg FULL_SPAN))
  |  "[" BOMType ("," BOMType)* "]"
      => (BOM.BomType.makeRegion (
        BOM.BomType.Tuple (BOMType::SR),
        posToReg FULL_SPAN))
  | DomainTy "->" RangeTy
      => (BOM.BomType.makeRegion (
        BOM.BomType.Fun (
          let
            val (inp : BOM.BomType.t list, exn : BOM.BomType.t list) = DomainTy
          in
            (inp, exn, RangeTy)
          end),
        posToReg FULL_SPAN))
  | "any"
      => (BOM.BomType.makeRegion (BOM.BomType.Any, posToReg FULL_SPAN))
  | "vproc"
      => (BOM.BomType.makeRegion (BOM.BomType.VProc, posToReg FULL_SPAN))
  | "cont" TyArgs?
      => (BOM.BomType.makeRegion (BOM.BomType.Cont TyArgs, posToReg FULL_SPAN))
  | "addr" "<" BOMType ">"
      => (BOM.BomType.makeRegion (BOM.BomType.Addr BOMType, posToReg FULL_SPAN))
  | RawTy
      => (BOM.BomType.makeRegion (BOM.BomType.Raw RawTy, posToReg FULL_SPAN))
  ;

DomainTy
  : "(" BOMType ("," BOMType)* "/" (BOMType ("," BOMType)* => (BOMType::SR))? ")"
      => (BOMType::SR1, Option.getOpt (SR2, []))
  ;

RangeTy
  : %try BOMType
      => ([BOMType])
  | %try "(" BOMType ("," BOMType)* ")"
      => (BOMType::SR)
  ;

Field
  : PosInt ":" BOMType
      => (BOM.Field.makeRegion (
        BOM.Field.Immutable (PosInt, BOMType),
        posToReg FULL_SPAN))
  | PosInt "!" BOMType
      => (BOM.Field.makeRegion (
        BOM.Field.Mutable (PosInt, BOMType),
        posToReg FULL_SPAN))
  ;


PosInt
  : INT
      => (if #negate INT then
        ((error (posToReg FULL_SPAN, "Value must be positive"));
        IntInf.fromInt 0)
      else
        intInfFromINT INT)
  ;


FunDef
  : Attrs? BomId TyParams? "(" Params? ("/" Params)? ")" ReturnTy "=" BOMExp
      => (BOM.FunDef.makeRegion (
        BOM.FunDef.Def (Attrs, BomId, TyParams, optToList Params, optToList SR,
          ReturnTy, BOMExp),
        posToReg FULL_SPAN))
  ;

Attrs
  : "__attributes__" "(" string ("," string)* ")"
      => (BOM.Attrs.makeRegion (
        BOM.Attrs.T (string::SR),
        posToReg FULL_SPAN))
  ;

BOMExp
  : "let" VarPat ("," VarPat)* "=" RHS BOMExp
      => (BOM.Exp.makeRegion (
        BOM.Exp.Let (VarPat::SR, RHS, BOMExp),
        posToReg FULL_SPAN))
  | "do" SimpleExp BOMExp
      => (BOM.Exp.makeRegion (
        BOM.Exp.Do (SimpleExp, BOMExp),
        posToReg FULL_SPAN))
  | "fun" FunDef ("and" FunDef)* BOMExp
      => (BOM.Exp.makeRegion (
        BOM.Exp.FunExp (FunDef::SR, BOMExp),
        posToReg FULL_SPAN))
  | "cont" BomId "(" Params? ")" "=" BOMExp BOMExp
      => (BOM.Exp.makeRegion (
        BOM.Exp.ContExp (BomId, Option.getOpt (Params, []), BOMExp1, BOMExp2),
        posToReg FULL_SPAN))
  | "if" SimpleExp "then" BOMExp "else" BOMExp
      => (BOM.Exp.makeRegion (
        BOM.Exp.If (SimpleExp, BOMExp1, BOMExp2),
        posToReg FULL_SPAN))
  | "case" SimpleExp "of" CaseRule ("|" CaseRule)*  "end"
      => (BOM.Exp.makeRegion (
        BOM.Exp.Case (SimpleExp,
          (checkCaseRule (CaseRule::SR, FULL_SPAN))),
        posToReg FULL_SPAN))
  | "typecase" TyParam "of" TyCaseRule ("|" TyCaseRule)* "end"
      => (BOM.Exp.makeRegion (
        BOM.Exp.Typecase (TyParam,
          TyCaseRule::(checkTyCaseRule (SR, FULL_SPAN))),
        posToReg FULL_SPAN))
  | "apply" LongValueId "(" Args? ("/" Args)? ")"
      => (BOM.Exp.makeRegion (
        BOM.Exp.Apply (
          LongValueId, Option.getOpt (Args, []), Option.getOpt (SR, [])),
        posToReg FULL_SPAN))
  | "throw" BomId TyArgs? "(" Args? ")"
      => (BOM.Exp.makeRegion (
        BOM.Exp.Throw (BomId, TyArgs, Option.getOpt (Args, [])),
        posToReg FULL_SPAN))
  | "return" "(" Args? ")"
      => (BOM.Exp.makeRegion (
        BOM.Exp.Return (Option.getOpt (Args, [])),
        posToReg FULL_SPAN))
  ;

Args
  : SimpleExp ("," SimpleExp)*
      => (SimpleExp::SR)
  ;


RHS
  : BOMExp
      => (BOM.RHS.makeRegion (BOM.RHS.Composite BOMExp, posToReg FULL_SPAN))
  | SimpleExp
      => (BOM.RHS.makeRegion (BOM.RHS.Simple SimpleExp, posToReg FULL_SPAN))
  ;


PrimOp
  : shortId => (BOM.PrimOp.fromSymbol shortId)
  ;

SimpleExp
  : PrimOp "(" Args ")"
      => (BOM.SimpleExp.makeRegion (
        BOM.SimpleExp.PrimOp (PrimOp, Args),
        posToReg FULL_SPAN))
  | "alloc" LongValueId "(" Args ")"
      => (BOM.SimpleExp.makeRegion (
        BOM.SimpleExp.AllocId (LongValueId, Args),
        posToReg FULL_SPAN))
  | "alloc" TyArgs "(" Args ")"
      => (BOM.SimpleExp.makeRegion (
        BOM.SimpleExp.AllocType (TyArgs, Args),
        posToReg FULL_SPAN))
  | "#" PosInt "(" SimpleExp ")" (":=" SimpleExp)?
      => (BOM.SimpleExp.makeRegion (
        BOM.SimpleExp.AtIndex (PosInt, SimpleExp, SR),
        posToReg FULL_SPAN))
  | "(" BOMType ")" SimpleExp
      => (BOM.SimpleExp.makeRegion (
        BOM.SimpleExp.TypeCast (BOMType, SimpleExp),
        posToReg FULL_SPAN))
  | "promote" "(" SimpleExp ")"
      => (BOM.SimpleExp.makeRegion (
        BOM.SimpleExp.Promote SimpleExp,
        posToReg FULL_SPAN))
  | "host_vproc"
      => (BOM.SimpleExp.makeRegion (
        BOM.SimpleExp.HostVproc,
        posToReg FULL_SPAN))
  | "vpload" "(" PosInt "," SimpleExp ")"
      => (BOM.SimpleExp.makeRegion (
        BOM.SimpleExp.VpLoad (PosInt, SimpleExp),
        posToReg FULL_SPAN))
  | "vpaddr" "(" PosInt "," SimpleExp ")"
      => (BOM.SimpleExp.makeRegion (
        BOM.SimpleExp.VpAddr (PosInt, SimpleExp),
        posToReg FULL_SPAN))
  | "vpstore" "(" PosInt "," SimpleExp "," SimpleExp ")"
      => (BOM.SimpleExp.makeRegion (
        BOM.SimpleExp.VpStore (PosInt, SimpleExp1, SimpleExp2),
        posToReg FULL_SPAN))
  | LongValueId
      => (BOM.SimpleExp.makeRegion (
        BOM.SimpleExp.Id LongValueId,
        posToReg FULL_SPAN))
  | Literal
      => (BOM.SimpleExp.makeRegion (
        BOM.SimpleExp.Lit Literal,
        posToReg FULL_SPAN))
  | ML_STRING
      => (BOM.SimpleExp.makeRegion (
        BOM.SimpleExp.MLString ML_STRING,
        posToReg FULL_SPAN))
  ;

(* We don't keep track of quite the right regions here *)
CaseRule
	: longid ( "(" VarPat ("," VarPat)* ")" )? "=>" BOMExp
      => (longRuleThunk (
        BOM.LongConId.fromSymbols longid,
        flatten SR,
        BOMExp,
        FULL_SPAN))
	| Literal "=>" BOMExp
      => (literalRuleThunk (Literal, BOMExp, FULL_SPAN))
	| idForLongid "(" VarPat ("," VarPat)* ")" "=>" BOMExp
      => (longRuleThunk (
        BOM.LongConId.fromSymbols idForLongid,
        VarPat::SR,
        BOMExp,
        FULL_SPAN))
	| BomId ":" BOMType "=>" BOMExp
      => (defaultRuleThunk (BOM.VarPat.makeRegion (BOM.VarPat.Var (
        BomId, SOME BOMType), posToReg FULL_SPAN), BOMExp, FULL_SPAN))
  | "_" (":" BOMType)? "=>" BOMExp
      => (defaultRuleThunk (BOM.VarPat.makeRegion (BOM.VarPat.Wild SR,
        posToReg FULL_SPAN), BOMExp, FULL_SPAN))
  | shortId "=>" BOMExp
      => (longOrDefaultRuleThunk (shortId, BOMExp, FULL_SPAN))
	;

(* CaseRule *)
(*   : LongConId "(" VarPat ("," VarPat)* ")" "=>" BOMExp *)
(*       => (print "emitting LongConId\n"; BOM.CaseRule.makeRegion ( *)
(*           BOM.CaseRule.LongRule (LongConId, VarPat::SR, BOMExp), *)
(*           posToReg FULL_SPAN)) *)
(*   | %try LongConId "=>" BOMExp *)
(*       => (print "emitting LongRule\n"; BOM.CaseRule.makeRegion ( *)
(*           BOM.CaseRule.LongRule (LongConId, [], BOMExp), *)
(*           posToReg FULL_SPAN)) *)

(*   (* : LongConId ("(" VarPat ("," VarPat)* ")")? "=>" BOMExp *) *)
(*   (*     => (BOM.CaseRule.makeRegion ( *) *)
(*   (*         (BOM.CaseRule.LongRule (LongConId, flatten SR, BOMExp), *) *)
(*   (*         posToReg FULL_SPAN))) *) *)
(*   | Literal "=>" BOMExp *)
(*       => (print "emitting LiteralRule\n";BOM.CaseRule.makeRegion ( *)
(*         BOM.CaseRule.LiteralRule (Literal, BOMExp), *)
(*         posToReg FULL_SPAN)) *)
(*   | %try VarPat "=>" BOMExp *)
(*       => (print "emitting DefaultRule\n"; BOM.CaseRule.makeRegion ( *)
(*         BOM.CaseRule.DefaultRule (VarPat, BOMExp), *)
(*         posToReg FULL_SPAN)) *)

(*   ; *)

(* CaseDefault *)
(*   : VarPat "=>" BOMExp *)
(*       => (BOM.CaseRule.makeRegion ( *)
(*         BOM.CaseRule.DefaultRule (VarPat, BOMExp), *)
(*         posToReg FULL_SPAN)) *)
(*   ; *)

VarPat
  : BomId (":" BOMType)?
      => (BOM.VarPat.makeRegion (
        BOM.VarPat.Var (BomId, SR),
        posToReg FULL_SPAN))
  | "_" (":" BOMType)?
      => (BOM.VarPat.makeRegion (BOM.VarPat.Wild SR, posToReg FULL_SPAN))
  ;

TyCaseRule
  : BOMType "=>" BOMExp
      => (BOM.TyCaseRule.makeRegion (
        BOM.TyCaseRule.TyRule (BOMType, BOMExp),
        posToReg FULL_SPAN))
  | "_" "=>" BOMExp
      => (BOM.TyCaseRule.makeRegion (
        BOM.TyCaseRule.Default BOMExp,
        posToReg FULL_SPAN))

  ;

(* TyCaseDefault *)
(*   : "_" "=>" BOMExp *)
(*       => (BOM.TyCaseRule.makeRegion ( *)
(*         BOM.TyCaseRule.Default BOMExp, *)
(*         posToReg FULL_SPAN)) *)
(*   ; *)

Literal
  : INT
      => (BOM.Literal.makeRegion (
        BOM.Literal.PosInt (    (* FIXME: Not sure if they leave the ~ in "digits"? *)
          let
            val myInt = intInfFromINT INT
            val sign = if (#negate INT) then ~1 else 1
          in
            IntInf.* (myInt, sign)
          end),
        posToReg FULL_SPAN))
  | REAL (* I assume that matching REAL will pull in the "-" *)
      => (BOM.Literal.makeRegion (
        BOM.Literal.Float (Option.valOf (Real.fromString REAL)),
        posToReg FULL_SPAN))
  | string
      => (BOM.Literal.makeRegion (BOM.Literal.String string, posToReg FULL_SPAN))
  | "nullVP"
      => (BOM.Literal.makeRegion (BOM.Literal.NullVP, posToReg FULL_SPAN))
  ;


CReturnTy
  : "void"
      => (BOM.CReturnTy.makeRegion (BOM.CReturnTy.Void, posToReg FULL_SPAN))
  | CArgTy
      => (BOM.CReturnTy.makeRegion (
        BOM.CReturnTy.CArg CArgTy,
        posToReg FULL_SPAN))
  ;

CArgTy
  : RawTy
      => (BOM.CArgTy.makeRegion (BOM.CArgTy.Raw RawTy, posToReg FULL_SPAN))
  | "void" "*"
      => (BOM.CArgTy.makeRegion (BOM.CArgTy.VoidPointer, posToReg FULL_SPAN))
  ;

RawTy
  : "int8"
    => (BOM.RawTy.makeRegion (BOM.RawTy.Int8, posToReg FULL_SPAN))
  | "uint8"
    => (BOM.RawTy.makeRegion (BOM.RawTy.Uint8, posToReg FULL_SPAN))
  | "int16"
    => (BOM.RawTy.makeRegion (BOM.RawTy.Int16, posToReg FULL_SPAN))
  | "uint16"
    => (BOM.RawTy.makeRegion (BOM.RawTy.Uint16, posToReg FULL_SPAN))
  | "int32"
    => (BOM.RawTy.makeRegion (BOM.RawTy.Int32, posToReg FULL_SPAN))
  | "uint32"
    => (BOM.RawTy.makeRegion (BOM.RawTy.Uint32, posToReg FULL_SPAN))
  | "int64"
    => (BOM.RawTy.makeRegion (BOM.RawTy.Int64, posToReg FULL_SPAN))
  | "uint64"
    => (BOM.RawTy.makeRegion (BOM.RawTy.Uint64, posToReg FULL_SPAN))
  | "float32"
    => (BOM.RawTy.makeRegion (BOM.RawTy.Float32, posToReg FULL_SPAN))
  | "float64"
    => (BOM.RawTy.makeRegion (BOM.RawTy.Float64, posToReg FULL_SPAN))
  ;

ReturnTy
  : "noreturn"
      => ([])
  | %try "->" BOMType
      => ([BOMType])
  | %try "->" "(" BOMType ("," BOMType)* ")"
      => (BOMType::SR)
  ;

FunParams
  : "(" Params? (")" => ([]) | "/" Params ")" => (Params))
      => (Option.getOpt (Params, []), SR)
  ;

Params
  : VarPat ("," VarPat)*
      => (VarPat::SR)
  ;
