(* bom.grm
 *
 * COPYRIGHT (c) 2012 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *)

%name BOM;

%tokens
  : KW_addr   ("addr")
  | KW_alloc  ("alloc")
(*  | KW_and  ("and")       *)
  | KW_any  ("any")
  | KW_apply  ("apply")
  | KW___attribute__ ("__attribute__")
  | KW_byte   ("byte")
(*  | KW_case   ("case")    *)
  | KW_ccall  ("ccall")
  | KW_cont   ("cont")
    | KW_constr     ("constr")
(*  | KW_datatype   ("datatype")    *)
  | KW_define   ("define")
  | KW_deque  ("deque")
(*  | KW_do     ("do")        *)
  | KW_double   ("double")
(*  | KW_else   ("else")    *)
(*  | KW_end  ("end")       *)
  | KW_enum   ("enum")
  | KW_extern   ("extern")
  | KW_float  ("float")
(*  | KW_fun  ("fun")       *)
  | KW_host_vproc ("host_vproc")
(*  | KW_if     ("if")      *)
  | KW_inline   ("inline")
  | KW_int  ("int")
(*  | KW_let  ("let")       *)
  | KW_long   ("long")
  | KW_module   ("module")
  | KW_noreturn   ("noreturn")
  | KW_nullVP   ("nullVP")
(*  | KW_of     ("of")      *)
  | KW_promote  ("promote")
  | KW_pure   ("pure")
        | KW_return   ("return")
  | KW_short  ("short")
  | KW_tag        ("tag")
(*  | KW_then   ("then")    *)
  | KW_throw  ("throw")
  | KW_typedef  ("typedef")
  | KW_unwrap   ("unwrap")
    | KW_use_rw     ("use_rw")
  | KW_vec128   ("vec128")
  | KW_void   ("void")
  | KW_vpaddr   ("vpaddr")
  | KW_vproc  ("vproc")
  | KW_vpload   ("vpload")
  | KW_vpstore  ("vpstore")
  | KW_wrap   ("wrap")
(*  | LP    ("(")       *)
(*  | RP    (")")       *)
(*  | LB    ("[")       *)
(*  | RB    ("]")       *)
(*      | LCB     ("{")                   *)
(*      | RCB     ("}")                   *)
(*  | HASH    ("#")       *)
(*  | STAR    ("*")       *)
(*  | COMMA     (",")       *)
(*  | EQ    ("=")       *)
(*  | COLON     (":")       *)
(*  | SLASH     ("/")       *)
(*  | SEMI    (";")       *)
(*  | BAR     ("|")       *)
(*  | WILD    ("_")       *)
(*  | BANG    ("!")       *)
(*  | AMP     ("&")       *)
  | DS    ("$")
(*  | ASSIGN  (":=")      *)
(*  | DARROW  ("=>")      *)
(*  | ARROW     ("->")      *)
    | DDARROW       ("==>")
(*  | LONGID of Atom.atom       *)
	(* Adding in new atoms *)
  | BOMID of Atom.atom
  | HLOPID of Atom.atom
  | TYPARAM of Atom.atom
  | PARAM of Atom.atom
  | FUNPARAM of Atom.atom
  | LONGTYID of ???
  | LONGCONID of ???
  | LONGVALUEID of ???
(*  | CHAR of ... *)
(*  | INT of ... *)
(*  | REAL of FloatLit.float    *)
(*  | STRING of string      *)
  | ML_STRING of IntInf.int vector
  ;

%defs(
    (* I'm not sure what name BomAst will be available as, so I'm
    putting this here until I do *)
    structure BOM = Ast.BomAst

	(* modified from the old bom.grm, to reflect the fact that we deal
	with "x list option" in a variety of places *)
	fun flattenToOption maybe =
	  case maybe of
		NONE => NONE
	  | SOME(x, xs) => SOME(x::xs)
	fun flattenToList maybe =
	  case maybe of
		NONE => []
	  | SOME(x, xs) => x::xs
);

BOMDecls
  : Definition*
    => (Definition)
  ;

Definition
  : "datatype" DataTypeDef ("and" DataTypeDef)*
    => BOM.Definition.makeRegion
      (BOM.Definition.Datatype (DataTypeDef, flattenToOption SR),
      posToReg FULL_SPAN)
  | "type" BomId TyParams? "=" BOMType ";"
    => BOM.Definition.makeRegion
      (BOM.Definition.TypeDefn (BomId, TyParams, BOMType),
      posToReg FULL_SPAN)
  | "define" Attrs? HLOpId TyParams? FunParams ReturnTy ("=" Exp)? ";"
    => BOM.Definition.makeRegion
      (BOM.Definition.DefineShortId (Attrs, HLOpId, TyParams, FunParams,
        ReturnTy, SR),
      posToReg FULL_SPAN)
  | "define" HLOpId TyParams? "=" LongValueId ";"
    => BOM.Definition.makeRegion
	  (BOM.Definition.DefineLongId (HLopId, TyParams, LongValueId),
	  posToReg FULL_SPAN)
  | "extern" CRetTy BomId "(" (CArgTy ("," CArgTy)* )? ")" Attrs ";"
    => BOM.Definition.makeRegion
	  (BOM.Definition.Extern (CRetTy, BomId,
		if Option.isSome SR1 then
		  SOME(CArgTy1::(flattenToList SR2))
		else
		  NONE,
		Attrs),
	  posToReg FULL_SPAN)
  | "fun" FunDef ("and" FunDef)* ";"
    => BOM.Definition.makeRegion
	  (BOM.Definition.Fun (FunDef::(flattenToList SR)),
	  posToReg FULL_SPAN)
(* TODO instance types *)
  ;


TyParams
  : "<" TYPARAM ("," TYPARAM)* ">"
	=> BOM.TyParams.T(TYPARAM::(flatten SR))
  ;


BOMType
  : "addr" "(" BOMType ")"
    =>
  | "any"
    =>
  | "enum" "(" PosInt ")"
    =>
  | RawType
    =>
  | "!" "[" BOMType ("," BOMType)* "]"
    =>
  | "[" BOMType ("," BOMType)* "]"
    =>
  | "fun" "(" TypeList "/" TypeList "->" TypeList ")"
    =>
(* QUESTION: perhaps cont, vproc, and deque can be predefined type constructors? *)
  | "cont" "(" TypeList ")"
    =>
  | "vproc"
    =>
  | "deque"
    =>
  | LONGID TypeArgs?
    =>
  ;

TypeArgs
  : "[" BOMType ("," BOMType)* "]"
    =>
  ;

TypeList
  : (BOMType ("," BOMType)* )?  => (flatten SR)
  ;

RawType
  : IntTy     =>
  | FloatTy   =>
  | "vec128"  =>
  ;

IntTy   : "byte"  =>
  | "short"   =>
  | "int"     =>
  | "long"  =>
  ;

FloatTy   : "float"   =>
  | "double"  =>
  ;

HLOpDef
  : FunParams ReturnTy ("=" BOMExp)?
    =>
  | "=" longid TypeParams?
    =>
  ;

CRetTy
  : "void"  =>
  | CArgTy  =>
  ;

CArgTy
  : RawType   =>
  | "void" "*"  =>
  ;

Attrs
  : (* empty *)   => ([])
  | "__attribute__" "(" "(" Attr ("," Attr)* ")" ")"
    => (Attr :: SR)
  ;

Attr
  : "pure"  =>
  | "alloc"   =>
  | "noreturn"  =>
  ;

ReturnTy
  : "noreturn"    =>
  | ":" BOMType     =>
  | ":" "(" TypeList ")"  =>
  ;

optAttrs
  : optAttr* =>
  ;


optAttr
  : "inline"  =>
  | "pure"  =>
  | "constr"  =>
  ;

FunParams
  : "(" Params ("/" Params)? ")"    =>
  ;

Params
  : (VarPat ("," VarPat)* )?    =>
  ;

BOMExp
  : "let" LHS "=" RHS BOMExp
    =>
  | "do" RHS BOMExp
    =>
  | "fun" BOMLambda ("and" BOMLambda)* BOMExp
    =>
  | "cont" CLambda BOMExp
    =>
  | "if" "(" SimpleExp ")" "then" BOMExp "else" BOMExp
    =>
  | "if" LONGID "(" Args ")" "then" BOMExp "else" BOMExp
    =>
  | "apply" longid "(" Args ("/" Args)? ")"
    =>
  | "throw" LONGID "(" Args ")"
    =>
  | "return" "(" Args ")"
    =>
  | HLOpQId "(" Args ("/" Args)? ")"
    =>
  ;

BOMLambda
  : ID FunParams ":" FunReturnTy "=" BOMExp
    =>
  ;

FunReturnTy
  : BOMType
    =>
  | "(" TypeList ")"
    =>
  ;

CLambda
  : ID "(" Params ")" "=" BOMExp
    =>
  ;

LHS
  : VarPat
    =>
  | "(" Params ")"
    =>
  ;

RHS
  : BOMExp
    =>
  | NonSelectExp
    =>
  | "#" PosInt "(" SimpleExp ")" (":=" SimpleExp)?
    =>
  | "promote" "(" SimpleExp ")"
    =>
  | "ccall" ID "(" Args ")"
    =>
  | "vpstore" "(" PosInt "," SimpleExp "," SimpleExp ")"
    =>
  ;

NonSelectExp
  : "alloc" "(" Args ")"
    =>
  | "wrap" "(" SimpleExp ")"
    =>
  | "&" PosInt "(" SimpleExp ")"
    =>
  | "unwrap" "(" SimpleExp ")"
    =>
  | LONGID TypeArgs? ("(" Args ")")?
    =>
  | "(" BOMType ")" SimpleExp
    =>
  | Literal
    =>
  | ML_STRING
    =>
  | "host_vproc"
    =>
  | "vpload" "(" PosInt "," SimpleExp ")"
    =>
  | "vpaddr" "(" PosInt "," SimpleExp ")"
    =>
  ;

SimpleExp
  : NonSelectExp
    =>
  | "#" PosInt "(" SimpleExp ")"
    =>
  ;

Args
  : (SimpleExp ("," SimpleExp)* )?
    =>
  ;

Rules
  : Rule ("|" Rule)*
    =>
  ;

Rule
  : longid "(" VarPat ("," VarPat)* ")" "=>" BOMExp
    =>
  | longid "=>" BOMExp
    =>
  | Literal "=>" BOMExp
    =>
  ;

Default
  : VarPat "=>" BOMExp
     =>
  ;

VarPat
  : "_" (":" BOMType)?
    =>
  | ID ":" BOMType
    =>
  ;

Literal
  : "enum" "(" PosInt ")" (":" BOMType)?
    =>
  | "$" PosInt
    =>
  | INT (":" IntTy)?
    =>
  | REAL (":" FloatTy)?
    =>
  | STRING
    =>
  ;

HLOpId
  : HLOP
    =>
  ;

HLOpQId
  : QHLOP
    =>
  | HLOP
    =>
  ;

(** rewrite rules **)

LabelOpt
  : (* empty *)
    =>
  | longid COLON
    =>
  ;

Pattern
  : HLOpQId "(" PatternArgs ")"
    =>
  | "[" PatternArgs "]"
    =>
  | Literal
    =>
  | ID
    =>
  | "alloc" "(" PatternArgs ")"
    =>
   ;

PatternArgs
  : (* empty *)
    =>
  | Pattern ("," Pattern)*
    =>
  ;

Benefit
  : "{" PosInt "}"
    =>
  | "{" "}"
    =>
  | (* empty *)
    =>
  ;

PosInt
  : INT
    => (INT) ;  (* FIXME: check sign! *)
