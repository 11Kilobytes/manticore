(* hlrw-def.grm
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 *)

%name HLRWDef;

%tokens
        : LP            ("(")
        | RP            (")")
        | LBRKT         ("{")
        | RBRKT         ("}")
        | COLON         (":")
        | SEMI          (";")
        | COMMA         (",")
        | DDARROW       ("==>")
        | ID of Atom.atom
        | HLOP of Atom.atom
        | NUM of IntInf.int
        ;

%defs(

      val zero = IntInf.fromInt 0

      val label_counter = ref 0

      fun new_label () = let
          val ret_val = Atom.atom ("$rewrite" ^
                                   (Int.toString (!label_counter)))
      in
          label_counter := !label_counter + 1;
          ret_val
      end

);

File
        : Rewrite*
                => ( Rewrite : HLRWDefPT.file )
        ;

Rewrite
        : LabelOpt Pattern DDARROW Pattern Benefit ";"
                => ( HLRWDefPT.Rewrite {label = LabelOpt,
                                        lhs = Pattern1,
                                        rhs = Pattern2,
                                        weight = Benefit} )
        ;

LabelOpt
        : (* empty *)
                => ( new_label () )
        | ID COLON
                => ( ID )
        ;

Pattern
        : IdOrHLOp LP PatternArgs RP
                => ( HLRWDefPT.Call(IdOrHLOp, PatternArgs) )

        (* XXX - Should this support not just a 2-tuple? (Which
           corresponds to E_Alloc, which has a list of variable inputs.
           Will have to ultimately support matching much more of BOM. *)
        | LP Pattern COMMA Pattern RP
                => ( HLRWDefPT.Tuple(Pattern1, Pattern2) )

        | ID
                => ( HLRWDefPT.Var ID )
        ;

PatternArgs
        : (* empty *)
                => ( [] )
        | Pattern (COMMA Pattern)*
                => ( Pattern :: SR )
        ;

Benefit
        : LBRKT NUM RBRKT
                => ( NUM )
        | LBRKT RBRKT
                => ( zero )
        | (* Empty *)
                => ( zero )
        ;

IdOrHLOp
        : ID
                => ( ID )
        | HLOP
                => ( HLOP )
        ;
