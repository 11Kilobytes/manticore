(* migrate.bom
 * test parallel dispatch by migrating a fiber across every vproc.
 *)

module Migrate

  extern void M_Print (void*);
  extern void EnqueueOnVProc (void *, void *, void *, void *) __attribute__((alloc));
  extern void *ListVProcs (void *) __attribute__((alloc));

  fun init (u : enum(0) / exh : cont(any)) : enum(0) =
 
      do @default-scheduler-startup (/ exh)

      fun fib (i : int/ exh : cont(any)) : int =
	  if I32Lte(i, 0:int) then return (0:int)
	  else if I32Eq(i, 1:int) then return (1:int)
	  else 
	      let a : int = apply fib (I32Sub (i, 2: int)/ exh)
	      let b : int = apply fib (I32Sub (i, 1: int)/ exh)
	      return (I32Add(a, b))


      fun migrate (vp : vproc / exh : cont(any)) : () =
          cont k (x : enum(0)) = return ()
          let self : vproc = host_vproc
          do ccall EnqueueOnVProc (self, vp, enum(0), k)
          @forward (self, enum(0):signal / exh)

      fun loop (vps : list / exh : cont(any)) : () = 
	  case vps of 
	       enum(0):list => do ccall M_Print ("done migrating\n\000")
			       @forward (host_vproc, enum(0):signal / exh)
	     | CONS (vp : vproc, vps : list) => 
	       if Equal (vp, host_vproc)
		  then apply loop (vps / exh)
	          else do ccall M_Print ("migrating\n\000")
		       do apply migrate (vp / exh)
                       let x : int = apply fib (31 / exh)
		       do ccall M_Print ("migrated\n\000")
		       apply loop (vps / exh)
          end

      let self : vproc = host_vproc
      let vps : list = ccall ListVProcs (self)
      do apply loop (vps / exh)

      return (enum(0))
