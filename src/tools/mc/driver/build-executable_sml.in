(* build-executable.sml
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * @configure_input@
 *
 * A wrapper for the commands needed to assemble and link the output
 * of the Manticore compiler.
 *)

signature BUILD_EXECUTABLE = sig

    val build : {
            verbose : bool,     (* if true, print shell commands to stdout *)
            asmFile : string,   (* the assembly file generated by the compiler *)
            outFile : string    (* the name of the executable image. *)
          } -> OS.Process.status

end

structure BuildExecutableMLRISC :> BUILD_EXECUTABLE =
  struct

    structure PrintTbl = PrintTable
    structure PrintTblDbg = PrintTableDebug

    val cat = String.concatWith " "

    fun ++ ("", l) = l
      | ++ (opt, l) = opt::l

    infixr ++

    val isCrossCompiler = (@CROSS_COMPILING@ = 1)

    val ccCmd =  "@CC@"

    val cFlags = cat ("@CFLAGS@"
                    ++ "@CFLAG_M64@"
                    ++ [])

    fun ldFlags libName = let
          val libDirs = List.filter (fn path => OS.FileSys.access (path, [])) [
                  "@MANTICORE_SRCDIR@/lib/parallel-rt/build/" ^ libName,
                  "@MANTICORE_LIBDIR@",
                  "@prefix@/lib"
                ]
          val libDirs = List.map (fn path => "-L" ^ path) libDirs
          val rtLib = "-l" ^ libName
          in
            cat (libDirs @ (rtLib ++ "@LDFLAGS@" ++ "@LIBS@" ++ "-lpthread" ++ []))
          end

    fun systemWithTiming (cmd, mustPrint) = let
        val verbose = mustPrint orelse (Controls.get BasicControl.verbose > 0)
        val inclusiveStart = Time.now()
        val _ = (if verbose
                 then TextIO.print(cmd ^ "\n")
                 else ())
        val result = OS.Process.system cmd;
        in
          if verbose
            then TextIO.print(concat [
                "Compile finished in: ",
                (Time.toString (Time.- (Time.now(), inclusiveStart))),
                "\n"
              ])
            else ();
          result
        end

    fun cmd asmFile = let
        val gcStats = Controls.get BasicControl.gcStats
        val logging = Controls.get BasicControl.logging
        val debug = Controls.get BasicControl.debug
        val perf = Controls.get BasicControl.perf
        val direct = Controls.get BasicControl.direct
        val segstack = Controls.get BasicControl.segstack
        val resizestack = Controls.get BasicControl.resizestack
        val hybridstack = Controls.get BasicControl.hybridstack
        val lazyunderflow = Controls.get BasicControl.lazyunderflow
        val nosealingcapture = Controls.get BasicControl.nosealingcapture
        val linkstack = Controls.get BasicControl.linkstack

        (* remove the .s *)
        val asmPrefix = String.extract(asmFile, 0, SOME((String.size asmFile) - 2))

        fun compileTbl (emitter, optFlags, filename) = let
            val filenamec = concat[filename,".c"]
            val filenameo = concat[filename,".o"]

            (* emit code *)
            val _ = emitter filenamec

            val cmd = cat [ccCmd,cFlags,optFlags,"-Wno-unused-command-line-argument",
            " @LIBS@ -I @MANTICORE_SRCDIR@/lib/parallel-rt/gc -I @MANTICORE_SRCDIR@/lib/parallel-rt/include/",
            " -I @MANTICORE_SRCDIR@/include -o ",filenameo," -c ",filenamec]

            val _ = if OS.Process.isSuccess (systemWithTiming (cmd, false))
                         then ()
                         else raise Fail "failed to build GC header table code"

        in
            (filenameo, [filenamec, filenameo])
        end

    (* compile & collect all nessecary compiled GC header tables *)
    fun tableFiles () = let
        val basename = asmPrefix ^ "_hdr"
        val (result, temps) = compileTbl (PrintTbl.print, "-O2", basename)

        fun mkDebug () = let
                val (dbg_result, dbg_temps) =
                    compileTbl (PrintTblDbg.print, "-g -O0" , basename ^ "_debug")
            in
                (concat [result, " ", dbg_result], temps @ dbg_temps)
            end

        in
            if debug
            then mkDebug()
            else (result, temps)
        end

        val (files, temps) = tableFiles ()
        val debugFlags = "-g3 "^cFlags^" -O0 -fno-omit-frame-pointer @SANITIZER@"

        val (cFlags, libName) = (case (gcStats, logging, debug, perf, direct)
         of (true, false, false, false, false) => (cFlags, "mcrt-stats")
          | (_, false, false, false, false) => (cFlags, "mcrt")
          | (_, true, false, false, false) => (cFlags, "mcrt-log")
          | (_, false, true, false, false) => (debugFlags, "mcrt-debug")
          | (_, true, true, false, false) => (debugFlags, "mcrt-log-debug")
          | (_, _, _, true, false) => (cFlags, "mcrt-perf")

          | (gcStats, _, debug, _, true) => let (* handle various kinds of stacks *)
                val name =
                    (case (segstack, linkstack, resizestack, hybridstack)
                        of (false, false, false, false) => "mcrt-direct-nosealingcapture"
                         | (false, true, false, false) => "mcrt-linkstack"
                         | (false, false, true, false) => if nosealingcapture
                                                    then "mcrt-resizestack-nosealingcapture"
                                                    else "mcrt-resizestack"
                         | (false, false, false, true) => if nosealingcapture
                                                    then "mcrt-hybridstack-nosealingcapture"
                                                    else "mcrt-hybridstack"
                         | (true, false, false, false) =>
                            (case (lazyunderflow, nosealingcapture)
                              of (false, false) => "mcrt-segstack"
                               | (true, false) => "mcrt-segstack-lazyunderflow"
                               | (false, true) => "mcrt-segstack-nosealingcapture"
                               | (true, true) => "mcrt-segstack-lazyunderflow-nosealingcapture"
                               (* end case *))
                          (* end case *))
              in
                if debug
                    then (debugFlags, name ^ "-debug")
                else if gcStats
                    then (cFlags, name ^ "-stats")
                else (cFlags, name)
              end
        (* end case *))
    in
	(cat [ccCmd, cFlags, asmFile,files, ldFlags libName], temps)
    end

    fun build {verbose, asmFile, outFile} = if isCrossCompiler
	  then (
	    TextIO.output(TextIO.stdErr, "cross compiler cannot produce executables\n");
	    OS.Process.failure)
	  else let
                val (cmdline, temps) = cmd asmFile
                val cmd' = cat[cmdline, " -o ", outFile]
                val result = systemWithTiming (cmd', verbose);
                val keepTemps = Controls.get BasicControl.debug
                                orelse Controls.get BasicControl.keepTemps
	      in
                  if not keepTemps
                  then (List.app OS.FileSys.remove temps)
                  else ();
                  result
	      end

  end

structure BuildExecutableLLVM :> BUILD_EXECUTABLE = struct

    (* THE FULL SET OF 03 done by opt. you can get this info using:  -O3 -debug-pass=Arguments
    Pass Arguments:  -tti -targetlibinfo -tbaa -scoped-noalias -assumption-cache-tracker -verify -simplifycfg -domtree -sroa -early-cse -lower-expect
Pass Arguments:  -targetlibinfo -tti -tbaa -scoped-noalias -assumption-cache-tracker -forceattrs -inferattrs -ipsccp -globalopt -domtree -mem2reg -deadargelim -basicaa -aa -domtree -instcombine -simplifycfg -basiccg -globals-aa -prune-eh -inline -functionattrs -argpromotion -domtree -sroa -early-cse -lazy-value-info -jump-threading -correlated-propagation -simplifycfg -basicaa -aa -domtree -instcombine -tailcallelim -simplifycfg -reassociate -domtree -loops -loop-simplify -lcssa -loop-rotate -basicaa -aa -licm -loop-unswitch -simplifycfg -basicaa -aa -domtree -instcombine -loops -scalar-evolution -loop-simplify -lcssa -indvars -aa -loop-idiom -loop-deletion -loop-unroll -basicaa -aa -mldst-motion -aa -memdep -gvn -basicaa -aa -memdep -memcpyopt -sccp -domtree -demanded-bits -bdce -basicaa -aa -instcombine -lazy-value-info -jump-threading -correlated-propagation -domtree -basicaa -aa -memdep -dse -loops -loop-simplify -lcssa -aa -licm -adce -simplifycfg -basicaa -aa -domtree -instcombine -barrier -basiccg -rpo-functionattrs -elim-avail-extern -basiccg -globals-aa -float2int -domtree -loops -loop-simplify -lcssa -loop-rotate -branch-prob -block-freq -scalar-evolution -basicaa -aa -loop-accesses -demanded-bits -loop-vectorize -instcombine -scalar-evolution -aa -slp-vectorizer -simplifycfg -basicaa -aa -domtree -instcombine -loops -loop-simplify -lcssa -scalar-evolution -loop-unroll -basicaa -aa -instcombine -loop-simplify -lcssa -aa -licm -scalar-evolution -alignment-from-assumptions -strip-dead-prototypes -globaldce -constmerge -verify
Pass Arguments:  -domtree

    *)


    (* LLVM does not make the stackmap section global in the output asm, so as a simple
     * workaround, we are just going to find/replace it
     *)
    fun makeStackMapGlobl verbose asmFile =
	let
        (* TODO shouldn't the output name be different on linux vs mac? *)
        val cmd = "perl -i -pe \"s/__LLVM_StackMaps:/.globl __LLVM_StackMaps\n__LLVM_StackMaps:/\" " ^ asmFile
        val _ = if verbose then TextIO.print(cmd ^ "\n") else ()
	    val stat = OS.Process.system cmd
	in () end

    (* when disabling the use of the return-address stack, we run a script that
     * appropriately replaces call/ret instructions with push/pop-jmp instead.
     *)
    fun removeCallRet verbose asmPrefix =
	let
        (* TODO shouldn't the output name be different on linux vs mac? *)
        val newFile = asmPrefix ^ "_noras.s"
        val cmd = "python @MANTICORE_SRCDIR@/tools/noras/noras.py " ^ asmPrefix ^ ".s > " ^ newFile
        val _ = if verbose then TextIO.print(cmd ^ "\n") else ()
	    val stat = OS.Process.system cmd
	in newFile end


    (* TOOLS *)
    val cat = String.concatWith " "

    fun isDirect() = Controls.get BasicControl.direct
    fun noRas() = Controls.get BasicControl.noras

    fun pathToBin binaryName = let
          val dir = "@LLVM_DIR@"
          in
            if dir = ""
              then raise Fail (
                "This version of Manticore was not configured with LLVM!\n\
                \See the README.md file for details about how to rebuild Manticore.\n\
                \")
              else dir ^ "/bin/" ^ binaryName
          end

    (**********************
     *  flags and options for opt
     **********************)

    val o_essential = ["-lower-expect"]
    val o_cleanup = ["-instcombine", "-globalopt", "-simplifycfg", "-tailcallelim", "-early-cse", "-simplifycfg", "-instcombine"]

  (* all of the basic cleanup passes LLVM has. things like adce were left off
   * not sure if this is reasonable ordering, just guessed
   *)
    val o_cleanupExtra = o_cleanup @ [
            "-reassociate",
            "-constprop",
            "-gvn",
            "-dce",
            "-simplifycfg",
            "-instcombine",
            "-simplifycfg"
          ]


    (***********************************************************
     custom optimization pipelines for basic function clean-up
     ***********************************************************)

    val o_basic = o_essential @ o_cleanup
    val o_normal = o_essential @ o_cleanupExtra

  (* run some fancier passes that might help further optimize allocation code *)
    val o_aggressive =
          o_essential @
          o_cleanupExtra @ [
              "-sink",
              "-mldst-motion",
              "-slp-vectorizer",
              "-instcombine",
              "-simplifycfg"
            ]

    val optLevels = [
            (0, o_essential),
            (1, o_basic),
            (2, o_normal),
            (3, o_aggressive),
            (4, ["-O1"]),
            (5, ["-O2"])
          ]

    (* opt passes that need to be performed before/after any passes *)
    fun o_wrapPasses verbose passes = let
          val firstPasses = ["-verify" (* , "-lint" *) ]
          val statsPasses = ["-stats", "-time-passes"]
          val passes = (case passes
                 of [] => firstPasses
                  |  _ => firstPasses @ passes @ ["-verify"]
                (* end case *))
          in
            if verbose then statsPasses @ passes else passes
          end

    fun doOpt verbose inputFile outputFile optPasses = let
        val options = (case Controls.get BasicControl.customOPT
                        of [] => optPasses
                         | custom => custom
                        (* end case *))

        val cmd = cat ([pathToBin "opt"] @ (o_wrapPasses verbose options) @ [inputFile, "-o", outputFile])
        val _ = if verbose then TextIO.print(cmd ^ "\n") else ()
    in
        OS.Process.system cmd
    end



    (**********************
     *  flags and options for llc
     **********************)

     val llcLevels = [
         (0, ["-O1"]),
         (1, ["-O2"]),
         (2, ["-O2"]),
         (3, ["-O3"])
     ]

  (* llc passes that need to be performed before/after any passes *)
    fun l_wrapPasses verbose passes = let
        val firstPasses = ["-relocation-model=pic"]
        val firstPasses = if not(isDirect())
                            then firstPasses @ ["-stack-alignment=16"]
                            else firstPasses
        val firstPasses = if Controls.get BasicControl.native
                            then firstPasses @ ["-mcpu=native"]
                            else firstPasses
        val statsPasses = ["-time-passes"] (* NOTE llc supports "-stats" but in Release mode it throws an error *)

        val passes = (case passes
                      of [] => firstPasses
                       |  _ => firstPasses @ passes
                       (* esac *))
    in
        if verbose then statsPasses @ passes else passes
    end

    fun doLLC verbose inputFile outputFile optPasses = let
        val options = (case Controls.get BasicControl.customLLC
                        of [] => optPasses
                         | custom => custom
                        (* end case *))

        val cmd = cat ([pathToBin "llc"] @ (l_wrapPasses verbose options) @ [inputFile, "-o", outputFile])
        val _ = if verbose then TextIO.print(cmd ^ "\n") else ()
    in
        OS.Process.system cmd
    end



    fun build {verbose, asmFile, outFile} = let
          val verbose = verbose orelse (Controls.get BasicControl.verbose > 0)
        (* take off the .ll *)
          val asmPrefix = String.extract(asmFile, 0, SOME((String.size asmFile) - 3))
        (* run opt. *)
        val commonName = asmPrefix ^ "_opt.bc"
        val optRun = doOpt verbose asmFile commonName
        val optOutput = let
            val allPasses = optLevels
            fun runIt passes = (if OS.Process.isSuccess (optRun passes)
                                then commonName
                                else raise Fail "failure in running LLVM opt!")

            val passes = List.find (fn (lvl, _) => (Controls.get BasicControl.llopt) = lvl) allPasses
        in
            (case passes
                of SOME (_, passList) => runIt passList
                 | NONE => runIt (#2(List.last allPasses))
            (* esac *))
        end

        (* run llc *)
        val llcOutput = asmPrefix ^ ".s"
        val llcRun = doLLC verbose optOutput llcOutput
        val result = let
            val allPasses = llcLevels
            fun runIt passes = (if OS.Process.isSuccess (llcRun passes)
                                then ()
                                else raise Fail "failure in running LLVM llc!")

            val passes = List.find (fn (lvl, _) => (Controls.get BasicControl.llopt) = lvl) allPasses
        in
            (case passes
                of SOME (_, passList) => runIt passList
                 | NONE => runIt (#2(List.last allPasses))
            (* esac *))
        end

        val _ = if isDirect()
                    then makeStackMapGlobl verbose llcOutput
                    else ()

        val llcOutput = if noRas()
                    then removeCallRet verbose asmPrefix
                    else llcOutput

        (* reuse the MLRISC linking etc *)
          val result = BuildExecutableMLRISC.build {
                  verbose=verbose, asmFile=llcOutput, outFile=outFile
                }
          in
            result
          end

  end
