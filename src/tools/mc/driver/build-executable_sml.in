(* build-executable.sml
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * @configure_input@
 *
 * A wrapper for the commands needed to assemble and link the output
 * of the Manticore compiler.
 *)

signature BUILD_EXECUTABLE = sig

    val build : {
	    verbose : bool,	(* if true, print shell commands to stdout *)
	    asmFile : string,	(* the assembly file generated by the compiler *)
	    outFile : string	(* the name of the executable image. *)
	  } -> OS.Process.status

end

structure BuildExecutableMLRISC :> BUILD_EXECUTABLE = struct
  
    structure PrintTbl = PrintTable
	structure PrintTblDbg = PrintTableDebug
    
    val cat = String.concatWith " "

    fun ++ ("", l) = l
      | ++ (opt, l) = opt::l

    infixr ++

    val isCrossCompiler = (@CROSS_COMPILING@ = 1)

    val ccCmd =  "@CC@"

    val cFlags = cat ("@CFLAGS@" 
                    ++ "@CFLAG_M64@" 
                    ++ [])

    fun ldFlags libName = let
	  val libDirs = List.filter (fn path => OS.FileSys.access (path, [])) [
          "@MANTICORE_SRCDIR@/lib/parallel-rt/build/" ^ libName,
          "@MANTICORE_LIBDIR@",
          "@prefix@/lib"
		]
	  val libDirs = List.map (fn path => "-L" ^ path) libDirs
	  val rtLib = "-l" ^ libName
	  in
	    cat (libDirs @ (rtLib ++ "@LDFLAGS@" ++ "@LIBS@" ++ "-lpthread" ++ []))
	  end

    fun systemWithTiming (cmd, mustPrint) = let
        val verbose = mustPrint orelse (Controls.get BasicControl.verbose > 0)
        val inclusiveStart = Time.now()
        val _ = (if verbose
	         then TextIO.print(cmd ^ "\n")
	         else ())
        val result = OS.Process.system cmd;
    in
        if verbose
        then TextIO.print(concat ["Compile finished in: ",
                                  (Time.toString (Time.- (Time.now(), inclusiveStart))),
                                  "\n"])
        else ();
        result
    end

    fun cmd asmFile = let
	  val gcStats = Controls.get BasicControl.gcStats
	  val logging = Controls.get BasicControl.logging
	  val debug = Controls.get BasicControl.debug
	  val perf = Controls.get BasicControl.perf
      val direct = Controls.get BasicControl.direct
      val segstack = Controls.get BasicControl.segstack
	  
	  val filename = OS.FileSys.tmpName()
          val filenamec = concat[filename,".c"]
          val filenameo = concat[filename,".o"]  
	  val gccfilename = cat [ccCmd,cFlags,"-O2 @LIBS@ -I @MANTICORE_SRCDIR@/lib/parallel-rt/gc -I @MANTICORE_SRCDIR@/lib/parallel-rt/include/ -I @MANTICORE_SRCDIR@/include -o",filenameo,"-std=c99 -c",filenamec]
	  val _ = PrintTbl.print filenamec
	  val _ = systemWithTiming (gccfilename, false)
	  
	  fun tableFiles () =
              if (debug) 
              then let
		      val filenamedebug = OS.FileSys.tmpName()
		      val filenamedebugc = concat[filenamedebug,".c"]
		      val filenamedebugo = concat[filenamedebug,".o"]  
		      val gccfilenamedebug = cat [ccCmd,cFlags,"-O0 @LIBS@ -I @MANTICORE_SRCDIR@/lib/parallel-rt/gc -I @MANTICORE_SRCDIR@/lib/parallel-rt/include/ -I @MANTICORE_SRCDIR@/include -o",filenamedebugo,"-std=c99 -c",filenamedebugc]
		      val _ = PrintTblDbg.print filenamedebugc
		      val _ = systemWithTiming (gccfilenamedebug, false)
	          in
                      (concat[filenameo," ",filenamedebugo],
                       [filenamec, filenameo, filenamedebugc, filenamedebugo])
                  end
              else 
                  (filenameo, [filenamec, filenameo])
                  
        val (files, temps) = tableFiles ()

        val (cFlags, libName) = (case (gcStats, logging, debug, perf, direct, segstack)
         of (true, false, false, false, false, false) => (cFlags, "mcrt-stats")
          | (_, false, false, false, false, false) => (cFlags, "mcrt")
          | (false, false, false, false, true, false) => (cFlags, "mcrt-direct")
          | (true, false, false, false, true, false) => (cFlags, "mcrt-direct-stats")
          | (false, false, false, false, true, true) => (cFlags, "mcrt-segstack")
          | (true, false, false, false, true, true) => (cFlags, "mcrt-segstack-stats")
          | (_, true, false, false, false, false) => (cFlags, "mcrt-log")
          | (_, false, true, false, false, false) => ("-g "^cFlags^" -O0", "mcrt-debug")
          | (_, true, true, false, false, false) => ("-g "^cFlags^" -O0", "mcrt-log-debug")
          | (_, _, _, true, false, false) => (cFlags, "mcrt-perf")
        (* end case *))
    in
	(cat [ccCmd, cFlags, asmFile,files, ldFlags libName], temps)
    end

    fun build {verbose, asmFile, outFile} = if isCrossCompiler
	  then (
	    TextIO.output(TextIO.stdErr, "cross compiler cannot produce executables\n");
	    OS.Process.failure)
	  else let
                  val (cmdline, temps) = cmd asmFile
	          val cmd' = cat[cmdline, " -o ", outFile]
                  val result = systemWithTiming (cmd', verbose);
	          val debug = Controls.get BasicControl.debug
	      in
                  if not debug
                  then (List.app OS.FileSys.remove temps)
                  else ();
                  result
	      end

  end
  
structure BuildExecutableLLVM :> BUILD_EXECUTABLE = struct
    
    (* THE FULL SET OF 03 done by opt. you can get this info using:  -O3 -debug-pass=Arguments
    Pass Arguments:  -tti -targetlibinfo -tbaa -scoped-noalias -assumption-cache-tracker -verify -simplifycfg -domtree -sroa -early-cse -lower-expect
Pass Arguments:  -targetlibinfo -tti -tbaa -scoped-noalias -assumption-cache-tracker -forceattrs -inferattrs -ipsccp -globalopt -domtree -mem2reg -deadargelim -basicaa -aa -domtree -instcombine -simplifycfg -basiccg -globals-aa -prune-eh -inline -functionattrs -argpromotion -domtree -sroa -early-cse -lazy-value-info -jump-threading -correlated-propagation -simplifycfg -basicaa -aa -domtree -instcombine -tailcallelim -simplifycfg -reassociate -domtree -loops -loop-simplify -lcssa -loop-rotate -basicaa -aa -licm -loop-unswitch -simplifycfg -basicaa -aa -domtree -instcombine -loops -scalar-evolution -loop-simplify -lcssa -indvars -aa -loop-idiom -loop-deletion -loop-unroll -basicaa -aa -mldst-motion -aa -memdep -gvn -basicaa -aa -memdep -memcpyopt -sccp -domtree -demanded-bits -bdce -basicaa -aa -instcombine -lazy-value-info -jump-threading -correlated-propagation -domtree -basicaa -aa -memdep -dse -loops -loop-simplify -lcssa -aa -licm -adce -simplifycfg -basicaa -aa -domtree -instcombine -barrier -basiccg -rpo-functionattrs -elim-avail-extern -basiccg -globals-aa -float2int -domtree -loops -loop-simplify -lcssa -loop-rotate -branch-prob -block-freq -scalar-evolution -basicaa -aa -loop-accesses -demanded-bits -loop-vectorize -instcombine -scalar-evolution -aa -slp-vectorizer -simplifycfg -basicaa -aa -domtree -instcombine -loops -loop-simplify -lcssa -scalar-evolution -loop-unroll -basicaa -aa -instcombine -loop-simplify -lcssa -aa -licm -scalar-evolution -alignment-from-assumptions -strip-dead-prototypes -globaldce -constmerge -verify
Pass Arguments:  -domtree

    *)
    
    
    (* LLVM does not make the stackmap section global in the output asm, so as a simple
     * workaround, we are just going to find/replace it
     *)
    fun makeStackMapGlobl verbose asmFile =
	let
        (* TODO shouldn't the output name be different on linux vs mac? *)
        val cmd = "perl -i -pe \"s/__LLVM_StackMaps:/.globl __LLVM_StackMaps\n__LLVM_StackMaps:/\" " ^ asmFile
        val _ = if verbose then TextIO.print(cmd ^ "\n") else ()
	    val stat = OS.Process.system cmd
	in () end
    
    
    (* TOOLS *)
    val cat = String.concatWith " "
    
    fun isDirect() = Controls.get BasicControl.direct
    
    fun pathToBin binaryName = let
        val dir = "@LLVM_DIR@"
    in
        if String.size dir = 0 
        then raise Fail ("This version of Manticore was not configured with LLVM!\n" ^
                         "See the README.md file for details about how to rebuild Manticore.\n")
                         
        else dir ^ "/bin/" ^ binaryName
    end 
    
    (**********************
     *  flags and options for opt
     **********************)

    
    (* i dunno *)
    val o_analysis = [
        "-basicaa",
        "-aa",
        "-memdep",
        "-domtree"
    ]
    
    val o_essential = ["-lower-expect"]
    
    (* all of the basic cleanup passes LLVM has. things like adce were left off
       not sure if this is reasonable ordering, just guessed *)
    val o_cleanup = [
        "-simplifycfg",
        "-instcombine",
        "-reassociate",
        "-constprop",
        "-early-cse",
        "-gvn",
        "-dce",
        "-simplifycfg",
        "-instcombine",
        "-simplifycfg"
    ]
    
    val o_normal = o_analysis @ o_cleanup @ o_essential
    
    (* run some fancier passes that might help further optimize allocation code *)
    val o_aggressive = 
          o_analysis
        @ o_cleanup 
        @ o_analysis @ [
            "-sink",
            "-mldst-motion",
            "-slp-vectorizer",
            "-instcombine",
            "-simplifycfg"
        ]
        @ o_essential 
    
    val optLevels = [
        (0, o_essential),
        (1, o_normal),
        (2, o_aggressive),
        (3, ["-O1"]),
        (4, ["-O2"]),
        (5, ["-O3"])
    ]
    
    
    
    (* opt passes that need to be performed before/after any passes *)
    fun o_wrapPasses verbose passes = let
        val firstPasses = ["-targetlibinfo", "-tti", "-verify", "-lint"]
        val statsPasses = ["-stats", "-time-passes"]
        
        val passes = (case passes 
                      of [] => firstPasses
                       |  _ => firstPasses @ passes @ ["-verify"]
                       (* esac *))
    in
        if verbose then statsPasses @ passes else passes
    end
    
    fun doOpt verbose inputFile outputFile optPasses = let
        val cmd = cat ([pathToBin "opt"] @ (o_wrapPasses verbose optPasses) @ [inputFile, "-o", outputFile])
        val _ = if verbose then TextIO.print(cmd ^ "\n") else ()
    in
        OS.Process.system cmd
    end
    
    
    
    (**********************
     *  flags and options for llc
     **********************)
     
     (* no reason to not use O3 with llc. The same passes are run for O1 through O3 and
        the same code is output.  
        
        Use -mcpu=native to get code optimized for the specific CPU
        instead of generic x86-64 instruction set. Seems to only hurt/make performance less stable.
        would need to experiment more 
        
        *)
     val llcLevels = [
         (0, ["-O3"])
     ]
    
    (* llc passes that need to be performed before/after any passes *)
    fun l_wrapPasses verbose passes = let
        val firstPasses = if isDirect() then [] else ["-stack-alignment=16"]
        val statsPasses = ["-time-passes"] (* NOTE llc supports "-stats" but in Release mode it throws an error *)
        
        val passes = (case passes 
                      of [] => firstPasses
                       |  _ => firstPasses @ passes
                       (* esac *))
    in
        if verbose then statsPasses @ passes else passes
    end
    
    fun doLLC verbose inputFile outputFile optPasses = let
        val cmd = cat ([pathToBin "llc"] @ (l_wrapPasses verbose optPasses) @ [inputFile, "-o", outputFile])
        val _ = if verbose then TextIO.print(cmd ^ "\n") else ()
    in
        OS.Process.system cmd
    end
    
    

    fun build {verbose, asmFile, outFile} = let
        val verbose = verbose orelse (Controls.get BasicControl.verbose > 0)
        
        (* take off the .ll *)
        val asmPrefix = String.extract(asmFile, 0, SOME((String.size asmFile) - 3))
        
        (* run opt. we do not need to run opt if the llopt level is set to 0, because
           llc will already run a verification pass on the input. we do it anyways though
           so we can run the linter. *)
        val commonName = asmPrefix ^ "_opt.bc" 
        val optRun = doOpt verbose asmFile commonName
        val optOutput = let
            val allPasses = optLevels
            fun runIt passes = (optRun passes ; commonName)
            
            val passes = List.find (fn (lvl, _) => (Controls.get BasicControl.llopt) = lvl) allPasses
        in
            (case passes
                of SOME (_, passList) => runIt passList
                 | NONE => runIt (#2(List.last allPasses))
            (* esac *))
        end
            
        (* run llc *)
        val llcOutput = asmPrefix ^ ".s"
        val llcRun = doLLC verbose optOutput llcOutput
        val result = let
            val allPasses = llcLevels
            fun runIt passes = llcRun passes
            
            val passes = List.find (fn (lvl, _) => (Controls.get BasicControl.llopt) = lvl) allPasses
        in
            (case passes
                of SOME (_, passList) => runIt passList
                 | NONE => runIt (#2(List.last allPasses))
            (* esac *))
        end
        
        val _ = if isDirect()
                    then makeStackMapGlobl verbose llcOutput
                    else ()
            
        (* reuse the MLRISC linking etc *)
        val result = BuildExecutableMLRISC.build {verbose=verbose, asmFile=llcOutput, outFile=outFile}
    in
        result
    end

end
