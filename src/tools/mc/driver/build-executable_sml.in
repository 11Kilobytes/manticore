(* build-executable.sml
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * @configure_input@
 *
 * A wrapper for the commands needed to assemble and link the output
 * of the Manticore compiler.
 *)

signature BUILD_EXECUTABLE = sig

    val build : {
	    verbose : bool,	(* if true, print shell commands to stdout *)
	    asmFile : string,	(* the assembly file generated by the compiler *)
	    outFile : string	(* the name of the executable image. *)
	  } -> OS.Process.status

end

structure BuildExecutableMLRISC :> BUILD_EXECUTABLE = struct
  
    structure PrintTbl = PrintTable
	structure PrintTblDbg = PrintTableDebug
    
    val usedLLVM = Controls.get BasicControl.llvm

    val cat = String.concatWith " "

    fun ++ ("", l) = l
      | ++ (opt, l) = opt::l

    infixr ++

    val isCrossCompiler = (@CROSS_COMPILING@ = 1)

    val ccCmd =  "@CC@"

    val cFlags = cat ("@CFLAGS@" 
                    ++ "@CFLAG_M64@" 
                    ++ (if usedLLVM then "-DLLVM" else "") 
                    ++ [])

    fun ldFlags libName = let
	  val libDirs = List.filter (fn path => OS.FileSys.access (path, [])) [
          "@MANTICORE_SRCDIR@/lib/parallel-rt/build/" ^ libName,
          "@MANTICORE_LIBDIR@",
          "@prefix@/lib"
		]
	  val libDirs = List.map (fn path => "-L" ^ path) libDirs
	  val rtLib = "-l" ^ libName
	  in
	    cat (libDirs @ (rtLib ++ "@LDFLAGS@" ++ "@LIBS@" ++ "-lpthread" ++ []))
	  end

    fun systemWithTiming (cmd, mustPrint) = let
        val verbose = mustPrint orelse (Controls.get BasicControl.verbose > 0)
        val inclusiveStart = Time.now()
        val _ = (if verbose
	         then TextIO.print(cmd ^ "\n")
	         else ())
        val result = OS.Process.system cmd;
    in
        if verbose
        then TextIO.print(concat ["Compile finished in: ",
                                  (Time.toString (Time.- (Time.now(), inclusiveStart))),
                                  "\n"])
        else ();
        result
    end

    fun cmd asmFile = let
	  val gcStats = Controls.get BasicControl.gcStats
	  val logging = Controls.get BasicControl.logging
	  val debug = Controls.get BasicControl.debug
	  val perf = Controls.get BasicControl.perf
	  
	  val filename = OS.FileSys.tmpName()
          val filenamec = concat[filename,".c"]
          val filenameo = concat[filename,".o"]  
	  val gccfilename = cat [ccCmd,cFlags,"-O2 @LIBS@ -I @MANTICORE_SRCDIR@/lib/parallel-rt/gc -I @MANTICORE_SRCDIR@/lib/parallel-rt/include/ -I @MANTICORE_SRCDIR@/include -o",filenameo,"-std=c99 -c",filenamec]
	  val _ = PrintTbl.print filenamec
	  val _ = systemWithTiming (gccfilename, false)
	  
	  fun tableFiles () =
              if (debug) 
              then let
		      val filenamedebug = OS.FileSys.tmpName()
		      val filenamedebugc = concat[filenamedebug,".c"]
		      val filenamedebugo = concat[filenamedebug,".o"]  
		      val gccfilenamedebug = cat [ccCmd,cFlags,"-O0 @LIBS@ -I @MANTICORE_SRCDIR@/lib/parallel-rt/gc -I @MANTICORE_SRCDIR@/lib/parallel-rt/include/ -I @MANTICORE_SRCDIR@/include -o",filenamedebugo,"-std=c99 -c",filenamedebugc]
		      val _ = PrintTblDbg.print filenamedebugc
		      val _ = systemWithTiming (gccfilenamedebug, false)
	          in
                      (concat[filenameo," ",filenamedebugo],
                       [filenamec, filenameo, filenamedebugc, filenamedebugo])
                  end
              else 
                  (filenameo, [filenamec, filenameo])
                  
        val (files, temps) = tableFiles ()

        val (cFlags, libName) = (case (gcStats, logging, debug, perf)
         of (true, false, false, false) => (cFlags, "mcrt-stats")
          | (_, false, false, false) => (cFlags, "mcrt")
          | (_, true, false, false) => (cFlags, "mcrt-log")
          | (_, false, true, false) => ("-g "^cFlags^" -O0", "mcrt-debug")
          | (_, true, true, false) => ("-g "^cFlags^" -O0", "mcrt-log-debug")
          | (_, _, _, true) => (cFlags, "mcrt-perf")
        (* end case *))
    in
	(cat [ccCmd, cFlags, asmFile,files, ldFlags libName], temps)
    end

    fun build {verbose, asmFile, outFile} = if isCrossCompiler
	  then (
	    TextIO.output(TextIO.stdErr, "cross compiler cannot produce executables\n");
	    OS.Process.failure)
	  else let
                  val (cmdline, temps) = cmd asmFile
	          val cmd' = cat[cmdline, " -o ", outFile]
                  val result = systemWithTiming (cmd', verbose);
	          val debug = Controls.get BasicControl.debug
	      in
                  if not debug
                  then (List.app OS.FileSys.remove temps)
                  else ();
                  result
	      end

  end
  
structure BuildExecutableLLVM :> BUILD_EXECUTABLE = struct
    
    (* THE FULL SET OF 03 done by opt. you can get this info using:  -O3 -debug-pass=Arguments
    Pass Arguments:  -tti -targetlibinfo -tbaa -scoped-noalias -assumption-cache-tracker -verify -simplifycfg -domtree -sroa -early-cse -lower-expect
Pass Arguments:  -targetlibinfo -tti -tbaa -scoped-noalias -assumption-cache-tracker -forceattrs -inferattrs -ipsccp -globalopt -domtree -mem2reg -deadargelim -basicaa -aa -domtree -instcombine -simplifycfg -basiccg -globals-aa -prune-eh -inline -functionattrs -argpromotion -domtree -sroa -early-cse -lazy-value-info -jump-threading -correlated-propagation -simplifycfg -basicaa -aa -domtree -instcombine -tailcallelim -simplifycfg -reassociate -domtree -loops -loop-simplify -lcssa -loop-rotate -basicaa -aa -licm -loop-unswitch -simplifycfg -basicaa -aa -domtree -instcombine -loops -scalar-evolution -loop-simplify -lcssa -indvars -aa -loop-idiom -loop-deletion -loop-unroll -basicaa -aa -mldst-motion -aa -memdep -gvn -basicaa -aa -memdep -memcpyopt -sccp -domtree -demanded-bits -bdce -basicaa -aa -instcombine -lazy-value-info -jump-threading -correlated-propagation -domtree -basicaa -aa -memdep -dse -loops -loop-simplify -lcssa -aa -licm -adce -simplifycfg -basicaa -aa -domtree -instcombine -barrier -basiccg -rpo-functionattrs -elim-avail-extern -basiccg -globals-aa -float2int -domtree -loops -loop-simplify -lcssa -loop-rotate -branch-prob -block-freq -scalar-evolution -basicaa -aa -loop-accesses -demanded-bits -loop-vectorize -instcombine -scalar-evolution -aa -slp-vectorizer -simplifycfg -basicaa -aa -domtree -instcombine -loops -loop-simplify -lcssa -scalar-evolution -loop-unroll -basicaa -aa -instcombine -loop-simplify -lcssa -aa -licm -scalar-evolution -alignment-from-assumptions -strip-dead-prototypes -globaldce -constmerge -verify
Pass Arguments:  -domtree

    *)
    
    (* TOOLS *)
    val cat = String.concatWith " "
    
    
    
    (**********************
     *  flags and options for opt
     **********************)
    val opt = "opt"
    
    (* TODO figure out why instcombine totally breaks our code ;) *)
    
    (* not really performance optimizations, just cleanup from initial generation. *)
    val o_cleanupPasses = []
    (*
    [
        "-strip-dead-prototypes",
        "-constmerge",
        "-codegenprepare"
    ] *)
    
    val o_aliasAnalysis = [
        "-basicaa",
        "-aa",
        "-memdep"
    ]
    
    (* just for testing instcombine for now *)
    val o_level1 = ["-instcombine"]
    
    (*
    
    [
        "-simplifycfg",
        "-reassociate",
        "-constprop",
        "-early-cse",
        "-dce",
        "-simplifycfg"
    ] *)
    
    
    val o_level2 = [
        "-simplifycfg",
        "-reassociate",
        "-constprop",
        "-early-cse",
        "-jump-threading",
        "-correlated-propagation",
        "-simplifycfg"
        ] @ o_aliasAnalysis @ [
        "-gvn",
        "-reassociate",
        "-constprop",
        "-early-cse",
        "-dce",
        "-simplifycfg"
    ]
    
    
    val o_level3 = 
        o_level2 @ 
        o_aliasAnalysis @ [
        "-sccp",
        "-adce",
        "-simplifycfg",
        "-branch-prob",
        "-block-freq"
    ]
    
    
    (* opt passes that need to be performed before/after any passes *)
    fun o_wrapPasses verbose passes = let
        val firstPasses = ["-targetlibinfo", "-tti", "-verify", "-lint"]
        val statsPasses = ["-stats", "-time-passes"]
        
        val passes = (case passes 
                      of [] => firstPasses
                       |  _ => firstPasses @ passes @ o_cleanupPasses @ ["-verify"]
                       (* esac *))
    in
        if verbose then statsPasses @ passes else passes
    end
    
    fun doOpt verbose inputFile outputFile optPasses = let
        val cmd = cat ([opt] @ (o_wrapPasses verbose optPasses) @ [inputFile, "-o", outputFile])
        val _ = if verbose then TextIO.print(cmd ^ "\n") else ()
    in
        OS.Process.system cmd
    end
    
    
    
    (**********************
     *  flags and options for llc
     **********************)
    val llc = "llc"
    
    val l_level1 = [] (* ["-O1"] *)
    val l_level2 = ["-O2"]
    val l_level3 = ["-O3"]
    
    (* llc passes that need to be performed before/after any passes *)
    fun l_wrapPasses verbose passes = let
        (* NOTE we need a frame pointer because our glue code uses it. "-disable-fp-elim",  *)
        val firstPasses = ["-stack-alignment=8"] (* TODO later this might be -stack-alignment=8 ? *)
        val statsPasses = ["-stats", "-time-passes"]
        
        val passes = (case passes 
                      of [] => firstPasses
                       |  _ => firstPasses @ passes
                       (* esac *))
    in
        if verbose then statsPasses @ passes else passes
    end
    
    fun doLLC verbose inputFile outputFile optPasses = let
        val cmd = cat ([llc] @ (l_wrapPasses verbose optPasses) @ [inputFile, "-o", outputFile])
        val _ = if verbose then TextIO.print(cmd ^ "\n") else ()
    in
        OS.Process.system cmd
    end
    
    

    fun build {verbose, asmFile, outFile} = let
        val verbose = verbose orelse (Controls.get BasicControl.verbose > 0)
        
        (* take off the .ll *)
        val asmPrefix = String.extract(asmFile, 0, SOME((String.size asmFile) - 3))
        
        (* run opt. we do not run opt if the llopt level is set to 0, because
           llc will already run a verification pass on the input. We _do_ miss
           out in the linter, but once this backend becomes more stable we should
           only enable the linter when running in debug mode. *)
        val commonName = asmPrefix ^ "_opt.bc" 
        val optRun = doOpt verbose asmFile commonName
        val optOutput = (case Controls.get BasicControl.llopt
                of 0 => asmFile (* don't bother running opt *)
                 | 1 => (optRun o_level1 ; commonName)
                 | 2 => (optRun o_level2 ; commonName)
                 | _ => (optRun o_level3 ; commonName)
            (* esac *))
            
            
        (* run llc *)
        val llcOutput = asmPrefix ^ ".s"
        val llcRun = doLLC verbose optOutput llcOutput
        val result = (case Controls.get BasicControl.llopt
            of 0 => llcRun []
             | 1 => llcRun l_level1
             | 2 => llcRun l_level2
             | _ => llcRun l_level3
            (* esac *))
            
        (* reuse the MLRISC linking etc *)
        val result = BuildExecutableMLRISC.build {verbose=verbose, asmFile=llcOutput, outFile=outFile}
    in
        result
    end

    (*fun build _ = raise Fail 
        ("not able to build LLVM executables yet!"
         ^ "\nyou chose opt level " ^ ((Int.toString o Controls.get) BasicControl.llopt))*)
end
