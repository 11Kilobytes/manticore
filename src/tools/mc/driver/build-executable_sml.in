(* build-executable.sml
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * @configure_input@
 *
 * A wrapper for the commands needed to assemble and link the output
 * of the Manticore compiler.
 *)

structure BuildExecutable : sig

    val build : {
	    verbose : bool,	(* if true, print shell commands to stdout *)
	    asmFile : string,	(* the assembly file generated by the compiler *)
	    outFile : string	(* the name of the executable image. *)
	  } -> OS.Process.status

  end = struct
  
    structure PrintTbl = PrintTable

    val cat = String.concatWith " "

    fun ++ ("", l) = l
      | ++ (opt, l) = opt::l

    infixr ++

    val isCrossCompiler = (@CROSS_COMPILING@ = 1)

    val ccCmd =  "@CC@"

    val cFlags = cat ("@CFLAGS@" ++ "@CFLAG_M64@" ++ [])

    fun ldFlags libName = let
	  val libDirs = List.filter (fn path => OS.FileSys.access (path, [])) [
		  "@prefix@/lib",
		  "@MANTICORE_LIBDIR@",
		  "@MANTICORE_SRCDIR@/lib/parallel-rt/build/" ^ libName
		]
	  val libDirs = List.map (fn path => "-L" ^ path) libDirs
	  val rtLib = "-l" ^ libName
	  in
	    cat (libDirs @ ("@LDFLAGS@" ++ rtLib ++ "@LIBS@" ++ "-lpthread" ++ []))
	  end

    fun cmd asmFile = let
	  val gcStats = Controls.get BasicControl.gcStats
	  val logging = Controls.get BasicControl.logging
	  val debug = Controls.get BasicControl.debug
	  val perf = Controls.get BasicControl.perf
	  val (cFlags, libName) = (case (gcStats, logging, debug, perf)
		 of (true, false, false, false) => (cFlags, "mcrt-stats")
		  | (_, false, false, false) => (cFlags, "mcrt")
		  | (_, true, false, false) => (cFlags, "mcrt-log")
		  | (_, false, true, false) => ("-g "^cFlags, "mcrt-debug")
		  | (_, true, true, false) => ("-g "^cFlags, "mcrt-log-debug")
		  | (_, _, _, true) => (cFlags, "mcrt-perf")
		(* end case *))
	  val filename = OS.FileSys.tmpName()
      val filenamec = concat[filename,".c"]
      val filenameo = concat[filename,".o"]  
	  val gccfilename = concat ["gcc -g -O2 -D_GNU_SOURCE -pedantic -m64 -D_THREAD_SAFE -I @MANTICORE_SRCDIR@/lib/parallel-rt/gc -I @MANTICORE_SRCDIR@/lib/parallel-rt/include/ -I @MANTICORE_SRCDIR@/include -DTARGET_DARWIN -DTARGET_X86_64 -o ",filenameo," -std=c99 -c ",filenamec]
	  val _ = PrintTbl.print filenamec
	  val _ = OS.Process.system gccfilename
	  in
	    cat [ccCmd, cFlags, asmFile,filenameo, ldFlags libName]
	  end

    fun build {verbose, asmFile, outFile} = if isCrossCompiler
	  then (
	    TextIO.output(TextIO.stdErr, "cross compiler cannot produce executables\n");
	    OS.Process.failure)
	  else let
	    val cmd' = cat[cmd asmFile, " -o ", outFile]
	    in
	      if verbose
		then TextIO.print(cmd' ^ "\n")
		else ();
	      OS.Process.system cmd'
	    end

  end
