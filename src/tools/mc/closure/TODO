      
    This is the TODO file for the direct-style transformation, which will revolve around the
    CPS -> CFG transformation.
    
Overall Goals of the improved continuation classification, in order to make closure conversion
modifications as simple as possible: 

- Every Throw must be marked with the type of throw it is: goto, ret, exn, other.
- Every Apply is marked as either tail or non-tail.
- All declared continuations must be marked with all types of their usage. While Conts are
  currently marked with their usage, it's imprecise.
    
(*******)    
    A rule to follow when going to direct-style is to check whether the current
    return continuation of a function is passed as such to an Apply. If the return continuation is the same,
    then it's a tail call in DS.
    
    If it changes, you generate a non-tail call followed by a goto to the new continuation
    passed as an argument (since that continuation must have been generated by the original
    cps transform, it should end up being mapped to a block within the same function). 
    This way, when you transform the throws of a function's return continuation into a return,
    everything goes to the right places.
    
    
(*******)
        There's a "bug" with the continuation classification in that the main function's return and
        exception handler continuations are misclassified as OtherConts. I think it's due to the fact
        that main's use count is zero. Not sure whether this is okay to allow or not, but it's good
        to keep in mind. Previously I thought exception handlers were misclassified, but my test program
        never installed any handlers, so they were all invoking the same one according to CFA, the
        "unexpected exception" handler.

(*******)

Currently, the let binding analysis only checks to see if a continuation declared escapes or not
by checking if it's used in the rhs, what we need to also consider is that unknown conts may be
thrown to, as in the example below, which is currently not classified at all:

    let tos<EBB7>#2:[cont(any),any] = vpload(vp<EBB5>#3+32)
    let rest<EBB8>#1:any = #1(tos<EBB7>#2)
    do vpstore(vp<EBB5>#3+32,rest<EBB8>#1)
    let act<EBB9>#1.1:cont(any) = #0(tos<EBB7>#2)
    throw act<EBB9>#1.1 con_STOP<EBB4>#1

(*******)
    Currently, throws to exception handlers are marked as returns, but they should be distinguished
    as throwing an exception so we know if we should perform a longjmp instead of a return.
       
       It should not be hard to add a new classification to both Cont and Throws to mark
       whether they're capturing/throwing an exception handler.
      
      
(*******)
    Classification of return continuations is not exactly what we want. It's correct in saying
that letJoinK below is used as a return continuation, since the letJoinK escapes the function
as a return continuation. However, the throws are not individually marked by their type of
usage, so it's incorrect to transform the true case's throw into a return.
      
throw to letJoinK<EF60>#2.1 is a return.


    cont letJoinK<EF60>#2.1 (lg<EF61>#4:[long]) =
        BODY OF THE CONTINUATION
      (**** End letJoinK<EF60>#2.1 ****)
      
      if I64Eq(_t<E391>#3,_lit<EF75>#1) then
        throw letJoinK<EF60>#2.1 _wlit<EF5F>#1
      else
        let _lit<EF76>#1:long = 2:long
        let _t<EF77>#1:long = U64Div(_t<E391>#3,_lit<EF76>#1)
        let _lit<EF78>#1:long = 1:long
        let _t<EF7A>#1:long = I64Add(_lit<EF5E>#2,_lit<EF78>#1)
        let _t<EF7B>#1:[long] = alloc (_t<EF7A>#1)
        apply lp<E2D6>#3.3 (_t<EF77>#1,_t<EF7B>#1 / letJoinK<EF60>#2.1)
        
        
We want to transform something like the above, where it's only used as either a goto OR
a return in the function, into this in CFG:

block letJoinK<EF60>#2.1 (lg<EF61>#4:[long]) =
    BODY OF THE CONTINUATION
  (**** End letJoinK<EF60>#2.1 ****)
  
  if I64Eq(_t<E391>#3,_lit<EF75>#1) then
    goto letJoinK<EF60>#2.1 _wlit<EF5F>#1       <- previously used as a goto continuation
  else
    let _lit<EF76>#1:long = 2:long
    let _t<EF77>#1:long = U64Div(_t<E391>#3,_lit<EF76>#1)
    let _lit<EF78>#1:long = 1:long
    let _t<EF7A>#1:long = I64Add(_lit<EF5E>#2,_lit<EF78>#1)
    let _t<EF7B>#1:[long] = alloc (_t<EF7A>#1)
    let returnVal = non-tail-call lp<E2D6>#3.3 (_t<EF77>#1,_t<EF7B>#1)  <- previously used here as a return continuation
    goto letJoinK<EF60>#2.1 returnVal
