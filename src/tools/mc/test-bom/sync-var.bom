(* sync-var.bom 
 * ivar implementation draft, not implement HLOp yet, such as
 *)

module SyncVar
  extern void M_Print (void *);

  fun init (wi : [int]; exh : cont(any)) : unit =
    let stop : enum(0) = 0
    let dummyTid : enum(0) = 0


    fun iPut (arg : (!(list, any, int), any); exh : cont(any)) : enum(0) = 
          let ivar : !(list, any, int) = #0(arg)
          let x : any = #1(arg)
          let readL : list = #0(ivar)
          let readflag : int = #2(ivar)
          let oldValue : any = CAS (&1(ivar), enum(0), x)
          case oldValue
           of enum(0) =>
(* FIXME: the following is an infinite loop! *)
                fun spin (; exh : cont(any)) : unit =
                      if (#2(ivar) = 0:int)
			then return (enum(0))
			else apply spin (; exh)
                do apply spin (; exh)
                case readL
                 of enum(0) => return (enum(0))
                  | CONS(hd : any, tl : list) =>                      
                      let fiber : cont(any) = #1(((int, cont(any)))hd)
                      do @enqueue(host_vproc, dummyTid, fiber)
                      fun wakeRead(l : list; exh : cont(any)) : enum(0) = 
                            case l 
                              of enum(0) => return (enum(0))
                               | CONS(hd' : any, tl' : list) =>
                                   let fiber' : cont(any) = #1(((int, cont(any)))hd')
                                   do @enqueue(host_vproc, dummyTid, fiber)
                                   apply wakeRead(tl'; exh)
                             end
                      apply wakeRead(tl; exh) 
                end
            | _ => 
                do ccall M_Print ("ivar is full\n\000")
                let vp : vproc = host_vproc
                @forward (vp, stop)
          end

    fun iGet (ivar : !(list, any, int); exh : cont(any)) : any =
          let readList : list = #0(ivar)
          let value : any = #1(ivar)
          let readFlag : int = #2(ivar)
          (* update readFlag *)
          do #2(ivar) := I32Add(readFlag, 1)
          case value
           of enum(0) =>
                (* atomic update, kinda like fetch and increment *)
                cont k (x : any) = return (x)
                let item : (enum(0), cont(any)) = alloc (dummyTid, k)
                (* atomic update *)
                do #0(ivar) := CONS(item, readList)
                do #2(ivar) := I32Sub(readFlag, 1)
                @forward (host_vproc, stop)
            | x : any =>
                do #2(ivar) := I32Sub(readFlag, 0)
                return (x)
                        
          end

     return (enum(0))
