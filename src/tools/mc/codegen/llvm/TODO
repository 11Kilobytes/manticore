LLVM backend todo list

***** TODOs *****      
    
    - MEMORY FENCES: It looks like we need to mark all loads/stores as 
    seq_cst to play it safe for now, in order to have a working memory fence in LLVM.
    
    - PAUSE: Need to implement the PAUSE primop with inline asm.
    
    - Floating point literals: integrate John's code and try it out.        
        
    - find out why instcombine breaks our programs (if it still does after we pass tests)
    
    - find out why the linter complains about those few things.
    
    - Pass all regression tests and benchmarks.
    
    
    
***** BUGS *****  

- The parray regression tests fail with the following error

PHI node has multiple entries for the same basic block with different incoming values!
  %minlen_cfg17654_2030B = phi i32* [ %r_203C3, %letJoinKCheck_cfg1970C_202EF ], [ %r_203BA, %letJoinKCheck_cfg1970C_202EF ]
label %letJoinKCheck_cfg1970C_202EF
  %r_203C3 = bitcast %_utupTy.39* %r_203BF to i32*
  %r_203BA = bitcast %_utupTy.39* %r_203B6 to i32*
  
  This is because in CFG, the same basic block can be the target of both branches
  of an if expression, but carry different values as args. We need to generate a dummy
  BB for the duplicate arm. This new BB will just unconditionally branch
  the original target to satisfy the requirements of SSA form (wrt what the
  definition of a basic block is).



***** FUTURE OPTIMIZATIONS *****

    - Add some aliasing information for the allocation pointer.
    
        We can use the 'noalias' attribute on the parameter of every function which is the allocation pointer.
        This will require changing the jwaCC type list (so the first one is an LT.allocPtrTy instead of an i64)
        and also adding a block of function prototype declarations, because only in the prototypes can you write
        noalias. This attribute corresponds to the 'restrict' keyword in C99. https://en.wikipedia.org/wiki/Restrict

   - Take advantage of LTO in LLVM,
   and to do this, we need to compile the entire runtime system to .ll
   files and then run the LLVM linker. More details about LTO:
    
    ------------------------------   
    12:42 (kavon) does anything other than DCE occur during LTO?

    12:42 (kavon) i could see maybe calling convention optimizations

    12:42 <joker-eph> kavon: we run all the optimizer potentially

    12:42 <@nlewycky> uh, yes. tons. loads.

    12:43 <@nlewycky> we do interprocedural constant propagation. we do inlining.
    we try to replace larger global variables that only have two possible values with booleans.
    we try to tighten linkage on every function or global. we merge identical constants.

    12:43 <joker-eph> kavon: if you're asking what is benefiting from LTO: since global 
    variables can also be turned into "internal" we can see all their uses and see that 
    their address is not taken and alias analysis is suddenly a lot better :)
    ------------------------------

    How to use LTO:

    You run clang as usual but you add -flto. The .o generated will be a bitcode file.
    it has a .o extension but it is exactly the same file that clang would generate with 
    `clang -c foo.c -o foo.o -S -emit-llvm`. All .ll and these special .o files need to
    be merged together in a single file, using llvm-link for example. Then you build
    the executable.
    
    Note that while manticore functions should be marked noinline due to
    GC checks being inserted early, runtime system calls that do not
    perform allocation are fair game. We'll want to annotate functions in the runtime system.
