LLVM backend todo list

***** TODOs *****      
    
    - Pass all regression tests and benchmarks that should pass.
        - find out why the linter complains about those few things.
        - find out why instcombine breaks our programs
    
    - Floating point literals: add regression tests to ensure that your
      custom conversion to LLVM floats outputs the right float literals. 
      You'll want to check for denormals, inf, negative zero, etc. Can just
      create a list of floats and print all of those corner cases out.
    
    
***** BUGS *****  

    - Linter complains of things like the following:
    
    Unusual: Address one pointer dereference
    %r_C65F = load i64*, i64** %r_C65E
    
    And it's caused by the following type of CFG
    
    let con_nil<B6C3>#2 = enum(0):enum(0)
    ...
    let t<BBC6>#1 = enum(0):enum(0)
    if NotEqual(con_nil<B6C3>,t<BBC6>)
      then $then<BBCB>(ep<B6BE>,con_nil<B6C3>,_lit<B6C4>,letJoinK<B6EB>)
      else $else<BBDA>(_wlit<B6C5>,letJoinK<B6EB>)

  block $then<BBCB>#3 (
    ep<BBC7>#2,
    con_nil<BBCA>#1,
    _lit<BBC9>#1,
    letJoinK<BBC8>#1
  ) =
    let xs<BBCC>#1 = ([any,any])con_nil<BBCA>
    let _t<BBCD>#1 = #1 xs<BBCC>

  where in the LLVM codegen, we're doing an unsafe constant propagation (because
  binding constants to vars in LLVM is not allowed/tricky) of con_nil
  to the 'then' block when it will never get there because the branch protects
  agianst it.
  
  Soln: we need to do those (gross) constant binding forms to prevent this!


***** FUTURE OPTIMIZATIONS *****

    - Add some aliasing information for the allocation pointer and codegen.
    
        We can use the 'noalias' and 'nocapture' attribute on the parameter of every function which is the allocation pointer.
        
        This will require changing the jwaCC type list (so the first one is an LT.allocPtrTy instead of an i64)
        
        and also adding a block of function prototype declarations, because only in the prototypes can you write noalias. NOTE debatable, GHC uses "i64* noalias nocapture %Hp_Arg" in function definitions.
        
         This attribute corresponds to the 'restrict' keyword in C99. https://en.wikipedia.org/wiki/Restrict

   - Take advantage of LTO in LLVM,
   and to do this, we need to compile the entire runtime system to .ll
   files and then run the LLVM linker. More details about LTO:
    
    ------------------------------   
    12:42 (kavon) does anything other than DCE occur during LTO?

    12:42 (kavon) i could see maybe calling convention optimizations

    12:42 <joker-eph> kavon: we run all the optimizer potentially

    12:42 <@nlewycky> uh, yes. tons. loads.

    12:43 <@nlewycky> we do interprocedural constant propagation. we do inlining.
    we try to replace larger global variables that only have two possible values with booleans.
    we try to tighten linkage on every function or global. we merge identical constants.

    12:43 <joker-eph> kavon: if you're asking what is benefiting from LTO: since global 
    variables can also be turned into "internal" we can see all their uses and see that 
    their address is not taken and alias analysis is suddenly a lot better :)
    ------------------------------

    How to use LTO:

    You run clang as usual but you add -flto. The .o generated will be a bitcode file.
    it has a .o extension but it is exactly the same file that clang would generate with 
    `clang -c foo.c -o foo.o -S -emit-llvm`. All .ll and these special .o files need to
    be merged together in a single file, using llvm-link for example. Then you build
    the executable.
    
    Note that while manticore functions should be marked noinline due to
    GC checks being inserted early, runtime system calls that do not
    perform allocation are fair game. We'll want to annotate functions in the runtime system.


***** NOTES *****

- MEMORY FENCES: It looks like we need to mark all loads/stores as 
seq_cst to play it safe for now, in order to have a working memory fence in LLVM.

19:48 (kavon) if i'm using the fence operation, do _all_ of my load/store instructions need to be marked with the same atomic ordering in order for it to have an effect?
19:52 <TNorthover> kavon: no, fences are capable of enforcing ordering even with non-atomic loads.
19:53 <TNorthover> kavon: you do have to be a bit careful though.
19:58 <TNorthover> kavon: for example if one thread did "data = whatever(); produced_data = true; fence" the two assignments could still be reordered (and even seen in a different order by different threads).
19:58 <TNorthover> Just the usual stuff really.
19:59 (kavon) ahh okay, i'll keep that in mind
