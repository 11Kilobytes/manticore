LLVM backend todo list

***** Larger Items *****

    - Heap limit checks
    
    - linking in the runtime system and generating the final binary
        one area we should be careful of here is the RTS glue code that needs
        to be changed if the llvm backend is used. Perhaps even on each side of the glue
        in the RTS code in that big switch loop of RunManticore, some things might have to
        be tweaked.
    
    

***** Medium Items *****

    - Floating point literals: unfortunately, we have to generate hex values that are the IEEE 754 encodings of the FloatLits (see the rant in LLVMBuilder). Current proposal is to write "asIEEESingle" and "asIEEEDouble" functions in FloatLit with type FloatLit.float -> string that gives us the hex string.
    
    - C Calls/Promotion: should just need to make sure we respect the ABI, with the added complexity of using the naked attribute. we might want to setup the stack pointer upon entering manticore function land to be 8 bytes shy of a 16 byte alignment so callq aligns the stack for us. this is of course not considering other things like what if the reg alloc
    decided to use push for spills, and we make a c call in the middle of a basic block. I believe we need to browse the LLVM source code to find out how the naked attribute is treated, because that preliminary testing earlier yielded some hoops that needed to be jumped through (mostly, I remember needing to call a special stack realigner function before making the actual c call to match the 16 byte ABI spec. we could always introduce a pass that inserts that realignment in a target non-specific way into LLVM's code generator, because I think this is an oversight.... we're probably the only people seriously making use of that attribute)
    
    - String literals: need to put these into basically a cache/table (there's infrastructure for this already but we'll have to see if it works for us) because string literals must be global variables in LLVM.
    
    - Manticore function calls: just assign vars to the right slots, and undefs to the other slots.

***** Small Items *****

    - The other literals (enums etc)
    
    - The remaining unimplemented primops and other stubbed out simple stuff, like
      sqrt and abs for floats are LLVM intrinsic calls.
      
    - Allocation: mostly just need to make sure the header bits are right
    
    - "store i32 ~1, i32* %r_12E17" should not emit SML style negative ints :)
      
      
      
Next up:
    - finish up manticore function calls
    - mark start blocks as having a ghost predecessor somehow so that real dangling blocks
      can be omitted or at least commented out when we perform toString, LLVM will complain
      about these dangling blocks if they refer to ghost vars.
    - enums and other literals
    - start running the whole thing through opt's verifier and fix bugs
    
