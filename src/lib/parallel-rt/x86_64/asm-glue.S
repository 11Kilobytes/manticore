/* asm-glue.S
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 */

#include "asm-defs.h"
#include "asm-offsets.h"
#include "registers.h"
#include "header-bits.h"

/* register(s) that are unused in manticore's calling convention. */
#define TMP_REG1            %rcx     // specifically must *not* be a callee-saved register.


//  Here's the layout we need upon entering Manticore functions when using CPS.
//  Something important here is that the base pointer is _not_ caller
//  saved once we enter manticore functions generated by LLVM. However,
//  the base pointer _is_ caller saved, and is nessecary to be setup
//  as shown below because MLRISC backend assigns spill slots by offsetting
//  from the base pointer, whereas the LLVM backend soley uses the stack ptr.
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// |   return address for RTS  | <- 16-byte align (RSP starts here)
// | - - - - - - - - - - - - - |
// |                           |
// |      Callee Save Area     |
// |                           |
// | - - - - - - - - - - - - - |
// |                           |  <- Base Pointer
// |                           |
// |      Spill Area           |
// |                           |
// |                           |  <- 8-byte align (RSP is here after ASM_Apply)
// | - - - - - - - - - - - - - |
// |   future callq PC slot    |  <- 16-byte align once C calls are made
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

//  Here's the layout we need upon entering Manticore functions when using DS.
//  We basically just dump all of the registers and write the return address,
//  allowing the functions to setup the frame themselves.
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// |                           |
// |      Callee Save Area     |
// |                           |
// | - - - - - - - - - - - - - |
// |   return address for RTS  | <- 16-byte align (RSP starts here)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/* Stack frame layout */
#define RBP_OFF		(1*8)  	/* offset off for saving %rbp */
#define RBX_OFF		(2*8)	/* offset off for saving %rbx */
#define R12_OFF		(3*8)	/* offset off for saving %r12 */
#define R13_OFF		(4*8)	/* offset off for saving %r13 */
#define R14_OFF		(5*8)	/* offset off for saving %r14 */
#define R15_OFF		(6*8)	/* offset off for saving %r15 */
#define CALLEE_END  (7*8)

/* ASM_Apply:
 *
 *	ReturnCode_t ASM_Apply (
 *	    VProc_t *vp,	-- host vproc; in %rdi
 *	    Addr_t cp,		-- code address of function; in %rsi
 *	    Value_t arg,	-- function argument; in %rdx
 *	    Value_t ep,		-- function environment ptr.; in %rcx
 *	    Value_t rk,		-- function return continuation; in %r8
 *	    Value_t ek)		-- function exception continuation; in %r9
 */
    .text
    .p2align 4, 0xCC
    .globl	_GSYM(ASM_Apply)
_GSYM(ASM_Apply):
    /* incoming RSP is 16-byte aligned according to SysV ABI */
    /* save C callee-save registers to frame */
    movq    %rbp, -RBP_OFF(%rsp)
    movq	%rbx, -RBX_OFF(%rsp)
    movq	%r12, -R12_OFF(%rsp)
    movq	%r13, -R13_OFF(%rsp)
    movq	%r14, -R14_OFF(%rsp)
    movq	%r15, -R15_OFF(%rsp)

    /* setup frame for spills */
    leaq    -CALLEE_END(%rsp), %rbp		// this is setup in case we're using MLRISC
    subq    $FRAME_SZB, %rsp

    /* setup standard arguments to the Manticore function */
    movq	%rdi,VPROC_PTR_REG	/* set vproc pointer */
    movq	%rsi,%r12		/* save code pointer in %r12 */
    movq	%rdx,STD_ARG_REG	/* standard argument */
    movq	%rcx,STD_EP_REG		/* environment pointer */
    movq	%r9,STD_EXH_REG		/* exception continuation */

#if !defined(LINKSTACK)

    movq	%r8,STD_CONT_REG	/* return continuation */

#else
    // r8 is a pointer to a linked-frame stack, so we setup rsp and rbp correctly.

    // the RTS stack at this point is 16-byte aligned, but our C shim expects rsp+8
    // to have such an alignment.
    pushq	%rax
    movq	%rsp, FFI_STK(VPROC_PTR_REG)	// save RTS stack
    // this is just like the epilog, minus the return,
    // since we're calling a function right now instead.
    // that function will return to whatever address RSP is pointing to.
    movq	%r8, %rsp
    popq	%rbp
#endif

    /* load Manticore state */
    movq	ALLOC_PTR(VPROC_PTR_REG),ALLOC_PTR_REG	/* load allocation pointer */
    jmp	*%r12


/* code address for uncaught exception continuation */
    .p2align 4, 0xCC
    .globl	_GSYM(ASM_UncaughtExn)
_GSYM(ASM_UncaughtExn):
    movq	$REQ_UncaughtExn, TMP_REG1
    jmp	switch_to_c

/* code address for return continuation */
    .p2align 4, 0xCC
    .globl	_GSYM(ASM_Return)
_GSYM(ASM_Return):
    movq	$REQ_Return, TMP_REG1
    jmp	switch_to_c

/* code address for putting the host vproc to sleep */
    .p2align 4, 0xCC
    .globl	_GSYM(ASM_VProcSleep)
_GSYM(ASM_VProcSleep):
    movq	$REQ_Sleep, TMP_REG1
    jmp	switch_to_c

#ifndef NDEBUG
/* r14 points at the current element of the spill area
 *  r15 points at the last element of the spill area
 */
    .p2align 4, 0xCC
    .globl	_GSYM(ASM_InvalidateSpillArea)
_GSYM(ASM_InvalidateSpillArea):
invalidate_spill_area:
    cmpq	%r14,%r15
    je	continue_to_c
    subq	$8,%r14
    movq	$0xdeadb,(%r14)
    jmp	invalidate_spill_area
#endif


// This is the PROLOGUE's Linked GC "invoke", where the root set was
// saved in a tuple allocated on the heap.
// INPUTS:
//     r11 - vproc
//     rsi - alloc pointer
//     rbp - call-site's link pointer, a complete continuation.
//     rbx - the root set pointer
//     rsp - pointer to the code address we must return to (it was pushed by call).
//
// OUTPUTS:
//     r11 - (unchanged from INPUT)
//     rsi - alloc pointer, bumped a bit.
//     rbp - (unchanged from INPUT)
//     rsp - pointer into the tuple object, ready to push RBP to the frame.
//
.p2align 4, 0xCC
.globl	_GSYM(ASM_LinkedStack_PrologueGC)
_GSYM(ASM_LinkedStack_PrologueGC):
//    We allocate a stack frame with the following layout:
// low                                                                       high
// [ FRAME TAG | _A_ | return addr | watermark | root ptr | manticore ret addr ]
//             ^                   ^
//         frame ptr           contents start
//
// Note that _A_ is not initialized here, but it will contain the call-site's link
// pointer, which is an ordinary heap object.

    popq	%r13			// pop the manticore return addr, which was pushed on the heap
    leaq	8(ALLOC_PTR_REG), %rsp  // RSP should be at a position s.t. a call just occurred

    movq	$(LINKFRAME_HDR(5)), -8(ALLOC_PTR_REG)

    leaq	_GSYM(ASM_LinkedStack_PrologueGC_Ret)(%rip), %r12
    movq	%r12, 8(ALLOC_PTR_REG)		// frame's return address
    movq	$0, 16(ALLOC_PTR_REG)		// watermark

    movq	%rbx, 24(ALLOC_PTR_REG)		// root ptr
    movq	%r13, 32(ALLOC_PTR_REG)		// write manticore ret addr

    addq	$48, ALLOC_PTR_REG			// bump alloc ptr
    jmp		_GSYM(ASM_LinkedStack_InvokeGC)


.p2align 4, 0xCC
.globl	_GSYM(ASM_LinkedStack_PrologueGC_Ret)
_GSYM(ASM_LinkedStack_PrologueGC_Ret):
// INPUT:
// r11 - vproc
// rsi - alloc ptr
// rsp - pointing to the beginning of the contents portion of the frame above.
// rbp - the link pointer (_A_) from the frame we allocated above.
//
// OUTPUT:
// r11 - vproc
// rsi - alloc ptr
// rbx - root pointer
// rbp - link pointer
    movq   16(%rsp), TMP_REG1
    movq   8(%rsp), %rbx
    jmp    *TMP_REG1


// Information for: ASM_LinkedStack_InvokeGC
//
// This is a STANDARD Linked GC "invoke", where the root set was
// saved in the stack frame. Thus, the only live registers at entry are:
//     r11 - vproc
//     rsi - alloc pointer
//     rsp - current, unfinished frame
//     rbp - call-site's link pointer
//
// Here, we set the STD_CONT_REG so it contains the final stack pointer,
// aka the actual return continuation, of the call to this label.
// This differs from the CPS-style version, which just places the code pointer
// in this register.
//
// final layout of a heap-allocated linked frame is given below
//
//  low addrs                                             high addrs
//
// [ GC Header | link ptr | RA slot | watermark | .. frame contents .. ]
//             ^
//          ptr to frame


#if defined(LINKSTACK)

/////////////////////////////////////////////
// Callec is implemented in the following way:
//
//    [ cont frame "K" we captured ]
//           ^     ^
//           |     |
//           |     ---------------------------+
//           |                                |
//    [ fp = |, code = *, fork frame ]      [ |, code = *, cont obj ]
//       ^
//       |
//    [ frame for clos passed to callec]
//
//  The idea here is that we create two objects that point to the cont K captured.
//  Because of promotion between GC cycles, the K may be relocated,
//  leaving either the fork-frame or cont-obj with a stale pointer to K.
//  However, when invoking either one of these items, we first check if K
//  had a forwarding pointer. If so, we get the new pointer to K and go there.


.p2align 4, 0xCC
.globl	_GSYM(ASM_Callec1)
.globl	_GSYM(ASM_Callec2)
_GSYM(ASM_Callec2):
    // not live since callec takes 1 arg.
    #define LAUNCHER %r12
    #define FORK %r13
    #define RETADDR %r14

    leaq  _GSYM(ASM_ContLauncher2)(%rip), RETADDR
    jmp  callec_impl

.p2align 4, 0xCC
_GSYM(ASM_Callec1):
    leaq  _GSYM(ASM_ContLauncher1)(%rip), RETADDR

callec_impl:
    // finish the frame we want to capture.
    push  %rbp
    movq  %rsp, %rbp    // cont is rbp

    // Allocate the launcher
    // [HDR | CodeP | Cont Frame ]
    movq  ALLOC_PTR_REG, LAUNCHER
    movq  $(BITPAT_HDR(0b10, 2)), TMP_REG1
    movq  TMP_REG1, -8(LAUNCHER)
    movq  RETADDR, (LAUNCHER) // set CodeP
    movq  %rbp, 8(LAUNCHER)

    // bump to get spot for fork.
    addq  $(3*8), ALLOC_PTR_REG

    movq  ALLOC_PTR_REG, FORK

    // Initialize the 'fork' frame, which acts as a read-barrier
    // that can be returned to like a normal frame.
    // [HDR | FP, the Cont Frame | RA | WM ]
    movq  $(LINKFRAME_HDR(3)), -8(FORK)
    // FP <- rbp will be set by callee
    leaq  _GSYM(ASM_ForkFrame)(%rip), TMP_REG1
    movq  TMP_REG1, 8(FORK)   // return address
    movq  $0, 16(FORK)   // AGE_Minor

    leaq  8(FORK), %rsp   // SP points at RA of Fork

    // bump again for size of the launcher
    addq  $(4*8), ALLOC_PTR_REG

    /***** invoke the function we were given *****/
    movq    (STD_ARG_REG), STD_EP_REG       // load environment pointer
    movq    8(STD_ARG_REG), TMP_REG1        // load code pointer
    movq    LAUNCHER, STD_ARG_REG           // pass the cont object
    jmp     *TMP_REG1                       // do the call, leaving stack pointer as-is

    #undef LAUNCHER
    #undef FORK
    #undef RETADDR

#endif // LINKSTACK


.p2align 4, 0xCC
.globl	_GSYM(ASM_ForkFrame)
_GSYM(ASM_ForkFrame):
    // the cont frame is in rbp. rax and r10 are live.
    #define KONT      %rbp
    #define TMP_REG2  %r14

    // check if the cont frame was promoted between GC cycles.
    movq  -8(KONT), TMP_REG1
    movq  TMP_REG1, TMP_REG2   // make a copy of hdr
    andq  $FWDPTR_TAG_MASK, TMP_REG1
    cmpq  $FWDPTR_TAG, TMP_REG1
    je   cvtFwdPtr
invokeFrame:
    movq  %rbp, %rsp
    popq  %rbp
    retq
cvtFwdPtr:
    // then cont was promoted, get the new location
    shrq  $FWDPTR_TAG_BITS, TMP_REG2
    movq  TMP_REG2, %rbp
    jmp   invokeFrame

    #undef KONT
    #undef TMP_REG2


.p2align 4, 0xCC
.globl	_GSYM(ASM_ContLauncher1)
.globl	_GSYM(ASM_ContLauncher2)
_GSYM(ASM_ContLauncher2):
    // setup args
    movq    $0, %r10         // set 2nd arg reg to 0 indicating an escape throw
    // **** fall-through ****
.p2align 4, 0x90              // must pad with NOPs!
_GSYM(ASM_ContLauncher1):
    // grab the pointer to the cont frame
    movq  8(STD_EP_REG), %rbp
    jmp   _GSYM(ASM_ForkFrame)

// special launcher for NewStack
.p2align 4, 0xCC
.globl  _GSYM(ASM_ContLauncher_Closure)
_GSYM(ASM_ContLauncher_Closure):
    // should be no need for a read barrier here.
    movq  8(STD_EP_REG), %rsp   // reinstate the base-frame stack ptr
    popq  %rbp                  // reinstate frame pointer and adjust SP

    // invoke the function closure
    movq  16(STD_EP_REG), TMP_REG1  // load clos
    movq  (TMP_REG1), STD_EP_REG    // set EP
    movq  8(TMP_REG1), TMP_REG1     // set CP
    movq  $M_UNIT, STD_ARG_REG      // pass unit
    jmpq  *TMP_REG1




.p2align 4, 0xCC
.globl	_GSYM(ASM_InvokeGC)
.globl	_GSYM(ASM_LinkedStack_InvokeGC)
_GSYM(ASM_InvokeGC):
_GSYM(ASM_LinkedStack_InvokeGC): // linkstack also uses this version!
/* this version is for MLRISC backend */
    movq	$REQ_GC, TMP_REG1
    jmp     switch_to_c



.p2align 4, 0xCC
.globl	_GSYM(ASM_InvokeGC_LLVM)
_GSYM(ASM_InvokeGC_LLVM):
// this version is for CPS-style LLVM. we need to save the
// ret addr and pop the frame when we invoke GC
    movq	$REQ_GC, TMP_REG1
    popq    STD_CONT_REG
// ------- FALL-THROUGH ----------
switch_to_c:
#if !defined(NDEBUG) && !defined(LINKSTACK)
// FIXME: disable this check once we've fixed the issues with missing roots
// consistency check for the garbage collector: overwrite all the entries in the spill area,
// all none of these entries should be live at this point.
//
    movq	%rsp,%r14
    movq	%rsp,%r15
    addq	$FRAME_SZB, %r14
    subq	$CALLEE_END, %r14
    jmp 	invalidate_spill_area
#endif

continue_to_c:

#ifdef LINKSTACK
    pushq	%rbp					// finish the frame
    movq	%rsp, STD_CONT_REG		// setup the return cont
    movq	FFI_STK(VPROC_PTR_REG), %rsp		// switch to the RTS stack
    popq	%r15			// undo alignment adjustment

    // for safety, kill known dead regs
    movq  $M_UNIT, STD_EP_REG
#endif

      /* save Manticore state */
    movq	STD_ARG_REG,STD_ARG(VPROC_PTR_REG)
    movq	STD_EP_REG,STD_EP(VPROC_PTR_REG)
    movq	STD_CONT_REG,STD_CONT(VPROC_PTR_REG)
    movq	STD_EXH_REG,STD_EXH(VPROC_PTR_REG)
    movq	ALLOC_PTR_REG,ALLOC_PTR(VPROC_PTR_REG)

    addq   $FRAME_SZB, %rsp       /* unbump stack pointer */

    /* restore C callee-save registers.  */
    movq	-RBP_OFF(%rsp),%rbp
    movq	-RBX_OFF(%rsp),%rbx
    movq	-R12_OFF(%rsp),%r12
    movq	-R13_OFF(%rsp),%r13
    movq	-R14_OFF(%rsp),%r14
    movq	-R15_OFF(%rsp),%r15
      /* return request code */
    movq	TMP_REG1,%rax
    ret


    .p2align 4, 0xCC
    .globl	_GSYM(ASM_Error)
_GSYM(ASM_Error):
    // if control-flow ends up here for linked-stacks, an unexpected
    // return occurred. See apply.c for possibilities.
    ud2

    .p2align 4, 0xCC
    .globl	_GSYM(ASM_ExecuteStack)
_GSYM(ASM_ExecuteStack):
    // this label is used as the codeP in apply.c when we want to resume
    // the retCont in ASM_Apply. It will jump here and then go.
    retq


#ifdef ENABLE_LOGGING
/* void ASM_GetTimeStamp (void *ts)
 *
 * Fill in the time stamp using a system-dependent call.
 */
    .p2align 4, 0xCC
    .globl	_GSYM(ASM_GetTimeStamp)
_GSYM(ASM_GetTimeStamp):
    pushq	%rbp
    movq	%rsp, %rbp

#if defined(HAVE_MACH_ABSOLUTE_TIME)
    /* ts->ts_mach = mach_absolute_time(); */
    pushq	%rbx
    subq	$8, %rsp
    movq	%rdi, %rbx
    call	_GSYM(mach_absolute_time)
    movq	%rax, (%rbx)
    addq	$8, %rsp
    popq	%rbx
#elif defined(HAVE_CLOCK_GETTIME)
    /* struct timespec t;
     * clock_gettime (CLOCK_REALTIME, &t);
     * ts->sec = t.tv_sec;
     * ts->frac = t.tv_nsec;
     */
    pushq	%rbx
    movq	%rdi, %rbx
    xorl	%edi, %edi
    subq	$16, %rsp
    movq	%rsp, %rsi
    call	_GSYM(clock_gettime)
    movq	(%rsp), %rax
    movl	%eax, (%rbx)
    movq	8(%rsp), %rax
    movl	%eax, 4(%rbx)
    addq	$16, %rsp
    popq	%rbx
#else
    /* struct timeval t;
     * gettimeofday (&t, 0);
     * ts->sec = t.tv_sec;
     * ts->frac = t.tv_usec;
     */
    pushq	%rbx
    movq	%rdi, %rbx
    leaq	-32(%rbp), %rdi
    subq	$24, %rsp
    xorl	%esi, %esi
    call	_GSYM(gettimeofday)
    movq	-32(%rbp), %rax
    movl	%eax, (%rbx)
    movl	-24(%rbp), %eax
    movl	%eax, 4(%rbx)
    addq	$24, %rsp
    popq	%rbx
#endif

    leave
    ret

#endif /* ENABLE_LOGGING */
