(* scheduler-startup.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Install an initial scheduler action on the vprocs in a system.
 *)

#include "runtime-offsets.def"
#include "types.def"

extern void *ListVProcs (void *) __attribute__((alloc));

define inline @spawn-on (f : fun (unit / exh -> unit), dst : vproc / exh : exh) : tid;
define inline @run (vp : vproc, act : sigact, tid : tid, fiber : fiber / exh : exh) noreturn;
define inline @thread-exit ( / exh : exh) noreturn;

(* debugging *)
extern void M_PrintDebug (void *);
extern void M_PrintInt (int);

(* Scheduler startup takes a scheduler action and installs it on all vprocs in the
 *  system.  There are two cases for dispatching this action:
 *   1. We run one action on the current vproc.
 *   2. For the other vprocs we dispatch a dummy fiber that installs the
 *      action.
 * Since dispatching involves the vproc queues and since we do not enforce ordering 
 * on vproc queue operations, the current vproc waits until all other vprocs are
 * initialized.
 *)

define @scheduler-startup (act : sigact / exh : exh) : () =
    let syncPoint : ![int] = galloc(0)
  (* length of a list *)
    fun length (ls : list, i : int) : int =
	  case ls
	   of NIL => return (i)
	    | CONS (_ : any, rest : list) => apply length (rest, I32Add(i,1))
	  end
    fun init (_ : unit / exh : exh) : unit =	  
          do vpstore (ATOMIC, host_vproc, TRUE)
	  cont k (_ : unit) = 
               do ccall M_PrintDebug ("Initializing top-level scheduler\n")
               let x : int = I32FetchAndAdd (syncPoint, 1)
               @thread-exit ( / exh)
	  (* in *)
	    @run (host_vproc, act, enum(0), k / exh)
    let self : vproc = host_vproc
  (* spawn the init function on all of the other vprocs *)
    fun spawnOnAll (vps : list / exh : exh) : () =
	  case vps
	   of NIL => return ()
	    | CONS (vp:vproc, rest:list) =>
		if Equal(vp, self) then
		  apply spawnOnAll (rest / exh)
		else
		  let _ : tid = @spawn-on (init, vp / exh)
		  (* in *)
		    apply spawnOnAll (rest / exh)
	  end
    cont startup (_ : unit) =
	  do vpstore(ATOMIC, self, TRUE)
	(* install the scheduler on remote vprocs *)
	  let vps : list = ccall ListVProcs(self)
	  let nVProcs : int = apply length (vps, 0)
	  let nVProcs : int = I32Sub (nVProcs, 1)
	  do apply spawnOnAll (vps / exh)
	(* wait for all vprocs to have started the init function *)
	  fun spinWait (_ : unit / exh : exh) : () = 
		let i : int = #0(syncPoint)     
		if I32Eq (i, nVProcs) then
		  do ccall M_PrintDebug ("All vprocs are ready\n")
		  return ()
		else
		  apply spinWait (UNIT / exh)
	  (* in *)
	    apply spinWait (UNIT / exh)
    (* in *)
      @run (self, act, enum(0), startup / exh)
;
