(* work-stealers-startup.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 * 
 * A top-level work-stealing scheduler for threads.  
 *
 * We use the following protocol for schedulers:
 *    (0) Make a list of all other vprocs starting after the current vproc
 *    (1) If the local vproc queue has a thread ready, run it.
 *    (2) Otherwise, go into steal mode:
 *        (2.1) Send out a thief thread to the first vproc
 *        (2.2) If a thread is available, put a worker thread back on the original vproc
 *        (2.3) Otherwise, do the same for the other vprocs until it seems wise to make the original vproc idle
 *)


#include "runtime-offsets.def"
#include "types.def"

define inline @list-append (arg : [list, list] / exh : exh) : list;

(* scheduling hlops *)
define inline @fiber (f : fiber_fun / exh : exh) : fiber;
define inline @run (vp : vproc, act : sigact, fgs : fgs, fiber : fiber / exh : exh) noreturn;
define inline @enqueue-on-vproc (dst : vproc, fgs : fgs, k : fiber / exh : exh) : ();
define inline @thread-exit ( / exh : exh) noreturn;
define @scheduler-startup (act : sigact / exh : exh) : ();
define @is-queue-gt-one (/ exh : exh) : bool;
define @is-queue-empty (/ exh : exh) : bool;
define @new-fgs (pinned : bool / exh : exh) : fgs;
define @get-fgs (vp : vproc / exh : exh) : fgs;

extern void *ListVProcs (void *) __attribute__((alloc));
extern void VProcPreempt (void *);

(* debugging *)
extern void M_Print (void*);
extern void M_PrintPtr (void *, void *);
extern void M_PrintDebug (void*);
extern void M_PrintLong (long);

define @work-stealers-startup ( / exh : exh) : () =

   fun orderVProcs (self : vproc, vps : list, acc : list / exh : exh) : list = 
       case vps
        of NIL => return (acc)
	 | CONS (vp : vproc, vps : list) =>
           if Equal (vp, self)
              then let arg :[list,list] = alloc (acc, vps)
                   let vprocs : list = @list-append (arg / exh)
                   return (vprocs)
              else apply orderVProcs (self, vps, CONS (vp, acc) / exh)
       end

   cont wsSwitch (s : signal) =
      (*do ccall M_Print ("WS switch\n")*)
      let self : vproc = host_vproc
      let vprocs : list = ccall ListVProcs (self)
      (* (0) *)
      let vprocs : list = apply orderVProcs (self, vprocs, NIL / exh)

      cont dispatch () =
         let vp : vproc = host_vproc
         let qitem : rdyq_item = @dequeue (vp / exh)
         let item : [fgs, fiber, rdyq_item] = ([fgs, fiber, rdyq_item]) qitem
         let fgs : fgs = #0 (item)
         let fiber : fiber = #1 (item)
         @run (vp, wsSwitch, fgs, fiber / exh)

      (* the maximum number of steal attempts before going to sleep *)
      let maxStealAttempts : int = 1000

      (* (2) *)
      cont steal (vprocs' : list) =
        case vprocs' 
          of NIL => 
	         do ccall M_Print ("Work stealer going to sleep\n")
                 throw dispatch ()
           | CONS (vp : vproc, vprocs' : list) => 
                 (* (2.1) *)
                 do ccall M_Print ("Sending thief to vproc\n")
                 cont thiefFiber (x : unit) = 
                    do ccall M_Print ("Thief fiber\n")
                    let hasElts : bool = @is-queue-gt-one ( / exh)
                    if hasElts
                       then (* (2.2) *)
                            do ccall M_Print ("Stealing a remote thread\n")
                            let qitem : rdyq_item = @dequeue (host_vproc / exh)
                            let item : [fgs, fiber, rdyq_item] = ([fgs, fiber, rdyq_item]) qitem
                            let fgs : fgs = #0 (item)
                            let fiber : fiber = #1 (item)
			    do @enqueue-on-vproc (self, fgs, fiber / exh)
                            (* Wake up the vproc *)
                            do ccall VProcPreempt (self)
                            @thread-exit (/ exh)
                       else (* (2.3) *)
                            do ccall M_Print ("Theif is giving up on this vproc\n")
                            throw steal (vprocs')
                let thiefFGS : fgs = @new-fgs (TRUE / exh)
                do @enqueue-on-vproc (vp, thiefFGS, thiefFiber / exh)
                throw dispatch ()
        end

      (* signal handling *)      
      if Equal (s, STOP) 
         then let qEmpty : bool = @is-queue-empty ( / exh)
              if qEmpty
                 then throw steal (vprocs)
                 else (* (1) *)
                      throw dispatch ()
         else (*do ccall M_Print("Handling preemption\n")*)
              let k : fiber = (fiber)s
              let fgs : fgs = @get-fgs (self / exh)
              do @enqueue (host_vproc, fgs, k / exh)
              throw dispatch ()

   do @scheduler-startup (wsSwitch / exh)
   return ()
;
