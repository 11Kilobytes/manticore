(* work-stealers-startup.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 * 
 * A top-level work-stealing scheduler for threads.  
 *
 * We use the following protocol for schedulers:
 *    (0) Make a list of all other vprocs starting after the current vproc
 *    (1) If the local vproc queue has a thread ready, run it.
 *    (2) Otherwise, go into steal mode:
 *        (2.1) Send out a thief thread to the first vproc
 *        (2.2) If a thread is available, put a worker thread back on the original vproc
 *        (2.3) Otherwise, do the same for the other vprocs until it seems wise to make the original vproc idle
 *)


#include "runtime-offsets.def"
#include "types.def"

define inline @list-append (arg : [list, list] / exh : exh) : list;

(* scheduling hlops *)
define inline @fiber (f : fiber_fun / exh : exh) : fiber;
define inline @run (vp : vproc, act : sigact, fgs : fgs, fiber : fiber / exh : exh) noreturn;
define inline @enqueue-on-vproc (dst : vproc, fgs : fgs, k : fiber / exh : exh) : ();
define inline @thread-exit ( / exh : exh) noreturn;
define @scheduler-startup (act : sigact / exh : exh) : ();
define @is-queue-gt-one (/ exh : exh) : bool;
define @is-queue-empty (/ exh : exh) : bool;
define @new-fgs (pinned : bool / exh : exh) : fgs;
define @get-fgs (vp : vproc / exh : exh) : fgs;

define @queue-length (pred : fun (fgs / exh -> bool) / exh : exh) : int;
define inline @dequeue-with-pred (vp : vproc, pred : fun (fgs / exh -> bool) / exh : exh) : option;

define inline @spin-lock (lock : spin_lock / exh : exh) : unit;
define inline @spin-unlock (lock : spin_lock / exh : exh) : unit;

extern void *ListVProcs (void *) __attribute__((alloc));
extern void VProcPreempt (void *);

(* debugging *)
extern void M_Print (void*);
extern void M_PrintPtr (void *, void *);
extern void M_PrintDebug (void*);
extern void M_PrintLong (long);

define @work-stealers-startup ( / exh : exh) : () =
  
   fun isUnpinned (fgs : fgs / exh : exh) : bool =
       let pinned : bool = #2(fgs)
       return (BNot (pinned))

   fun orderVProcs (self : vproc, vps : list, acc : list / exh : exh) : list = 
       case vps
        of NIL => return (acc)
	 | CONS (vp : vproc, vps : list) =>
           if Equal (vp, self)
              then let arg :[list,list] = alloc (acc, vps)
                   let vprocs : list = @list-append (arg / exh)
                   return (vprocs)
              else apply orderVProcs (self, vps, CONS (vp, acc) / exh)
       end

   fun withLock (lock : spin_lock, f : fun (unit / exh -> unit) / exh : exh) : () =
       let _ : unit = @spin-lock (lock / exh)
       let _ : unit = apply f (UNIT / exh)
       let _ : unit = @spin-unlock (lock / exh)
       return ()

   let sleepingLock : spin_lock = galloc (FALSE)
   let sleeping : ![list] = galloc (NIL)
  (* add the vproc to the sleeping list *)
   fun addToSleeping (vp : vproc / exh : exh) : () =
       fun doit (_ : unit / exh : exh) : unit =
           let rest : list = #0(sleeping)
           let sleepingVProcs : list = CONS (vp, rest)
           let sleepingVProcs : list = promote (sleepingVProcs)
           do #0(sleeping) := sleepingVProcs
           return (UNIT)
       apply withLock (sleepingLock, doit / exh)
  (* given some number of stealable threads, resuscitate at most that many sleeping vprocs *)
   fun resuscitates (n : int / exh : exh) : list =
       let resuscitates : ![list] = galloc (NIL)
       fun doit (_ : unit / exh : exh) : unit =
           fun takeN (i : int, ss : list, rs : list / exh : exh) : list =
               if I32Lte (i, n)
                  then case ss
			of NIL => 
			   do #0(sleeping) := ss
			   return (rs)
			 | CONS (r : vproc, rest : list) =>
                           let rs : list = CONS (r, rs)
			   apply takeN (I32Sub (i,1), rest, rs / exh)
                       end
                  else do #0(sleeping) := ss
		       return (rs)
           let sleepingVProcs : list = #0(sleeping)
           let rs : list = apply takeN (0, sleepingVProcs, NIL / exh)
           let rs : list = promote (rs)
           do #0(resuscitates) := rs
           return (UNIT)
       do apply withLock (sleepingLock, doit / exh)
       let rs : list = #0(resuscitates)
       return (rs)
  (* resuscitate any sleeping vprocs if there are stealable threads on the ready queue *)
   fun resuscitateVProcs (  / exh : exh) : () =
       let stealableFibers : int = @queue-length (isUnpinned / exh)
       let stealableFibers : int = I32Sub (stealableFibers,1)
       if I32Gt(stealableFibers, 0)
          then let rs : list = apply resuscitates (stealableFibers / exh)
               let dummyFgs : fgs = @new-fgs (TRUE / exh)
               cont dummyK (u : unit) = @thread-exit ( / exh)
               fun dispatchOn (vps : list / exh : exh) : () =
                   case vps
		    of NIL => return ()
		     | CONS (vp : vproc, rest : list) =>
                        do ccall M_Print ("Attempting to resuscitate\n")
                        do @enqueue-on-vproc (vp, dummyFgs, dummyK / exh)
                        apply dispatchOn (rest / exh)
                   end
               do apply dispatchOn (rs / exh)
               return ()
          else return ()

   cont wsSwitch (s : signal) =
      (*do ccall M_Print ("WS switch\n")*)
      let self : vproc = host_vproc
      let vprocs : list = ccall ListVProcs (self)
      (* (0) *)
      let vprocs : list = apply orderVProcs (self, vprocs, NIL / exh)

      cont dispatch () =
         let vp : vproc = host_vproc
         let qitem : rdyq_item = @dequeue (vp / exh)
         let item : [fgs, fiber, rdyq_item] = ([fgs, fiber, rdyq_item]) qitem
         let fgs : fgs = #0 (item)
         let fiber : fiber = #1 (item)
         @run (vp, wsSwitch, fgs, fiber / exh)

      (* the maximum number of steal attempts before going to sleep *)
      let maxStealAttempts : int = 1000

      (* (2) *)
      cont steal (vprocs' : list) =
        case vprocs' 
          of NIL =>
	         do ccall M_Print ("Going to sleep\n")
                 do apply addToSleeping (self / exh)
                 throw dispatch ()
           | CONS (vp : vproc, vprocs' : list) => 
                 (* (2.1) *)
                 do ccall M_Print ("Sending thief to vproc\n")
                 cont thiefFiber (x : unit) = 
                    do ccall M_Print ("Thief fiber\n")
                    let hasElts : bool = @is-queue-gt-one ( / exh)
                    if hasElts
                       then (* (2.2) *)
                            do ccall M_Print ("Stealing a remote thread\n")
                            let qitemOpt : option = @dequeue-with-pred (host_vproc, isUnpinned / exh)
                            case qitemOpt
			     of NONE => 
				do ccall M_Print ("Nothing to steal on this vproc\n")
                                throw steal (vprocs')
			      | SOME (qitem : rdyq_item) =>
                                let item : [fgs, fiber, rdyq_item] = ([fgs, fiber, rdyq_item]) qitem
                                let fgs : fgs = #0 (item)
                                let fiber : fiber = #1 (item)
			        do @enqueue-on-vproc (self, fgs, fiber / exh)
                                (* Wake up the vproc *)
                                do ccall VProcPreempt (self)
                                @thread-exit (/ exh)
                            end
                       else (* (2.3) *)
                            do ccall M_Print ("Thief is giving up on this vproc\n")
                            throw steal (vprocs')
                let thiefFGS : fgs = @new-fgs (TRUE / exh)
                do @enqueue-on-vproc (vp, thiefFGS, thiefFiber / exh)
                throw dispatch ()
        end

      (* signal handling *)      
      if Equal (s, STOP) 
         then let qEmpty : bool = @is-queue-empty ( / exh)
              if qEmpty
                 then throw steal (vprocs)
                 else (* (1) *)
                      throw dispatch ()
         else (*do ccall M_Print("Handling preemption\n")*)
              let k : fiber = (fiber)s
              let fgs : fgs = @get-fgs (self / exh)
              do @enqueue (host_vproc, fgs, k / exh)
             (* altert sleeping vprocs if new work is available*)
              do apply resuscitateVProcs ( / exh)
              throw dispatch ()

   do @scheduler-startup (wsSwitch / exh)
   return ()
;
