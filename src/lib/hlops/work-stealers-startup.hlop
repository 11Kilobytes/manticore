(* work-stealers-startup.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 * 
 * A top-level work-stealing scheduler for threads.  
 *
 * We use the following protocol for schedulers:
 *    (0) make a list of all other vprocs starting after the current vproc
 *    (1) if the local vproc queue has a thread ready, run it.
 *    (2) otherwise, go into steal mode:
 *        (2.1) send out a thief thread to the first vproc
 *        (2.2) if a thread is available, put a worker thread back on the original vproc
 *        (2.3) otherwise, do the same for the other vprocs until it seems wise to make the original vproc idle
 *)


#include "runtime-offsets.def"
#include "types.def"

define inline @list-append (arg : [list, list] / exh : exh) : list;

(* scheduling hlops *)
define inline @fiber (f : fiber_fun / exh : exh) : fiber;
define inline @run (vp : vproc, act : sigact, tid : tid, fiber : fiber / exh : exh) noreturn;
define inline @enqueue-on-vproc (dst : vproc, tid : tid, k : fiber / exh : exh) : ();
define inline @thread-exit ( / exh : exh) noreturn;
define @scheduler-startup (act : sigact / exh : exh) : ();
define @is-queue-gt-one (/ exh : exh) : bool;
define @is-queue-empty (/ exh : exh) : bool;

extern void *ListVProcs (void *) __attribute__((alloc));
(* debugging *)
extern void M_Print (void*);
extern void M_PrintDebug (void*);
extern void M_PrintLong (long);

define @work-stealers-startup ( / exh : exh) : () =

   fun orderVProcs (self : vproc, vps : list, acc : list / exh : exh) : list = 
       case vps
        of NIL => return (acc)
	 | CONS (vp : vproc, vps : list) =>
           if Equal (vp, self)
              then let arg :[list,list] = alloc (acc, vps)
                   let vprocs : list = @list-append (arg / exh)
                   return (vprocs)
              else apply orderVProcs (self, vps, CONS (vp, acc) / exh)
       end

   cont wsSwitch (s : signal) =
      do ccall M_Print ("WS switch\n")
      let self : vproc = host_vproc
      let x1 : long = 1234 : long
      let vprocs : list = ccall ListVProcs (self)
      (* (0) *)
      let vprocs : list = apply orderVProcs (self, vprocs, NIL / exh)

      cont dispatch () =
         let vp : vproc = host_vproc
         let qitem : rdyq_item = @dequeue (vp / exh)
         let item : [tid, fiber, rdyq_item] = ([tid, fiber, rdyq_item]) qitem
         let tid : tid = #0 (item)
         let fiber : fiber = #1 (item)
         @run (vp, wsSwitch, tid, fiber / exh)

      (* (2) *)
      cont steal (vprocs' : list) =
        do ccall M_Print ("Steal mode\n")
        case vprocs' 
          of NIL => do ccall M_Print ("Work stealer going to sleep\n")
                    throw dispatch ()
           | CONS (vp : vproc, vprocs' : list) => 
                 (* (2.1) *)
                 do ccall M_Print ("Sending thief to vproc\n")
                 cont k (x : unit) = 
                    do ccall M_Print ("Stealer continuation\n")
                    let hasElts : bool = @is-queue-gt-one ( / exh)
                    if hasElts
                       then (* (2.2) *)
                            let qitem : rdyq_item = @dequeue (host_vproc / exh)
                            let item : [tid, fiber, rdyq_item] = ([tid, fiber, rdyq_item]) qitem
                            let tid : tid = #0 (item)
                            let fiber : fiber = #1 (item)
(* BUG: for some reason, self is 0 at this point (but adding x1 fixes it...). *)
(*                            do ccall M_PrintLong (self)*)
do ccall M_PrintLong (x1)
			    do @enqueue-on-vproc (self, tid, fiber / exh)
                            @thread-exit (/ exh)
                       else (* (2.3) *)
			    cont fiber (_ : unit) = throw steal (vprocs')
                            let k : fiber = (fiber)fiber
                            do @enqueue-on-vproc (self, enum(0), k / exh)
                            @thread-exit (/ exh)
                do @enqueue-on-vproc (vp, enum(0), k / exh)
                throw dispatch ()
        end

      (* signal handling *)      
      if Equal (s, STOP) 
         then let qEmpty : bool = @is-queue-empty ( / exh)
              if qEmpty
                 then throw steal (vprocs)
                 else (* (1) *)
                      throw dispatch ()
         else do ccall M_Print("Handling preemption\n")
              let k : fiber = (fiber)s
              let tid : tid = enum(0)
              do @enqueue (host_vproc, tid, k / exh)
              throw dispatch ()

   do @scheduler-startup (wsSwitch / exh)
   return ()
;
