(* touch1.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * To touch a one-toucher future.
 *)

#include "types.def"
#include "futures.def"

define @get-work1 (q : work_queue / exh : exh) : ();

 extern void M_Print (void * ); 

define @touch1 (qf: [work_queue, future] / exh : exh) : any =
  let q : work_queue = #0(qf)
  let fp : future = #1(qf)
  let tmp : any = CAS (&0(fp), EMPTY_F, EVAL_F)

  if Equal (tmp, EMPTY_F)
    then (* the future is ready for evaluation *)
         let f : thunk = #1(fp)
         do #1(fp) := (thunk) $0
         (* may need exn handler for thunk. *)
         (* let exh : exh = ... *)
         (*do ccall M_Print ("applying thunk\n\000")*)
         let resultLocal : any = apply f (UNIT / exh)
         let result : any = promote (resultLocal)
         do #0(fp) := result (* one toucher, multiple touches *)
         return (result)

    else if Equal (tmp, STOLEN_F)
           then (* someone else is evaluating the future*)
                cont kLocal (result: any) = 
                     do ccall M_Print ("returning from wait\n\000")
                     return (result)
                let k : cont(any) = promote (kLocal)
   	        let tmpX : any = CAS (&0(fp), STOLEN_F, k)
 	        if Equal (tmpX, STOLEN_F)
	           then (* the future-cell writer can resume this thread via k *)
                        do ccall M_Print ("suspending on future\n\000")
                        do @get-work1 (q / exh) (* this should ultimately throw result to k *)
                        do ccall M_Print ("ERROR: should never get here\n\000")
                        return (tmpX) (* is this line unreachable? - ams *)
	          else (* the future value is ready *)
                       return (tmpX)
           else (* the future value is ready *)
                return (tmp)
;

(* let q : work_queue = #0(qf)
  let fp : future = #1(qf)
  let tmp : any = CAS (&0(fp), EMPTY_F, EVAL_F)
  if Equal (tmp, EMPTY_F)
    then let f : thunk = #1(fp)
         (* may need exn handler for thunk. *)
         (* let exh : exh = ... *)
         let result : any = apply f (UNIT / exh)
         do #0(fp) := result
         return (result)
    else 
         return (q)
*)

(*
  ... original notes from Tues 8/21 ...

  tmp = CAS(&(fp->state), EMPTY_F, EVAL_F);
  if (tmp == EMPTY_F) {
    f = fp->thunk;
    fp->thunk = NIL;
    return f();
  } else if (tmp != STOLEN_F) {
    return tmp;
  } else {
    callcc (fn k =>
      if (BCAS(&(fp->state), STOLEN_F, k)) {
        getWork();
      } else {
        return fp->state;
      })
  }    
*)
