(* touch1.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * To touch a one-toucher future.
 *)

#include "types.def"

define @getWork1 () : ();

define @touch1 (fp : ![any, fun (unit / exh -> any)] / exh : exh) : any =
                         (* state, thunk *)
  let tmp : any = CAS (&0(fp), EMPTY_F, EVAL_F)
  if Equal (tmp, EMPTY_F)
    then let f : fun (unit / exh -> any) = #1(fp)
         do #1(fp) := NIL
         (* need exn handler for thunk. *)
         (* let exh : exh = ... *)
         let result : any = apply f ( (* / exh *) )
         do #0(fp) := result (* one toucher, multiple touches *)
         return (result)
    else if NotEqual (tmp, STOLEN_F)
           then return (tmp)
           else cont k (result: any) = return (result)
	     let tmp' : any = CAS (&0(fp), STOLEN_F, k)
	     if Equal (tmp', STOLEN_F)
	       then @getWork1 ()
	       else return (tmp')
;

(*
  ... original notes from Tues 8/21 ...

  tmp = CAS(&(fp->state), EMPTY_F, EVAL_F);
  if (tmp == EMPTY_F) {
    f = fp->thunk;
    fp->thunk = NIL;
    return f();
  } else if (tmp != STOLEN_F) {
    return tmp;
  } else {
    callcc (fn k =>
      if (BCAS(&(fp->state), STOLEN_F, k)) {
        getWork();
      } else {
        return fp->state;
      })
  }    
*)
