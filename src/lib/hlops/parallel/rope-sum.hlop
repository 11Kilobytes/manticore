(* rope-sum.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * To sum the elements of a rope "leafwise parallel."
 *)

#include "types.def"
#include "futures.def"
#include "ropes.def"

define @rope-sum (q : work_queue / exh : exh) : fun (rope / exh -> ml_int) =
  fun rsum (r : rope / exh : exh) : ml_int =
    fun sumS (ns : list, acc : int / exh : exh) : int =
      case ns
        of NIL => return (acc)
         | CONS (mln : ml_int, ns : list) =>
             let n : int = #0(mln)
             let accX : int = I32Add (n, acc)
             let res : int = apply sumS (ns, accX / exh)
             return (res)            
      end
    fun sumP (r : rope / exh : exh) : ml_int = 
      case r
        of LEAF (len:ml_int, data:list) => 
             let res : int = apply sumS (data, 0 / exh)
	     let boxedRes : ml_int = alloc (res)
             return (boxedRes)
         | CAT (len:ml_int, depth:ml_int, r1:rope, r2:rope) =>
             fun th (u : unit / exh: exh) : ml_int = 
               let res : ml_int = apply sumP (r2 / exh)
               return (res)
             let qt : [work_queue, thunk] = alloc (q, th)
             let f2 : future = @future1-spawn (qt / exh)
             let s1 : ml_int = apply sumP (r1 / exh)
             let qf : [work_queue, future] = alloc (q, f2)
             let t2 : any = @future1-touch (qf / exh)
             let s2 : ml_int = (ml_int)t2
             let n1 : int = #0(s1)
             let n2 : int = #0(s2)
             let sum : int = I32Add (n1, n2)
             let boxedSum : ml_int = alloc (sum)
             return (boxedSum)
      end
    let res : ml_int = apply sumP (r / exh)
    return (res)
  return (rsum)
;
