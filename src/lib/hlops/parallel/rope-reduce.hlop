(* rope-reduce.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * For reducing the elements of a rope over its leaves in parallel, with a given associative operator.
 *)

#include "types.def"
#include "futures.def"
#include "ropes.def"

(* use_rw ropes; *)

(* REWRITE THIS SO IT'S CURRIED *)

define @rope-reduce (args : [(* o *) fun ([any, any] / exh -> any),
                             (* z *) any,
		             (* q *) work_queue,
		             (* r *) rope] / exh : exh) : rope =

  let o : fun ([any, any] / exh -> any) = #0(args)
  let q : work_queue = #1(args)
  let r : rope = #2(args)

  fun red (r : rope / exh : exh) : any = 
    case r
      of LEAF(len:ml_int, data:list) =>
           let tup : [fun ([any, any] / exh - any), any, list] = alloc (o, z, data)
           let x : any = @list-foldl (tup / exh)
           return (x)
       | CAT(len:ml_int, depth:ml_int, r1:rope, r2:rope) =
           fun th (u : unit / exh : exh) : rope =
             let result : rope = apply red (r2 / exh)
             return (result)
           let qt : [work_queue, thunk] = alloc (q, th)
           let fut : future = @future1 (qt / exh)
           let qf : [work_queue, future] = alloc (q, fut)
           let newR1 : any = apply red (r1 / exh)
           let newR2 : any = @touch1 (qf / exh)
           let tup : [any, any] = alloc (newR1, newR2)
           let res : any = apply o (tup / exh)
           return (newR)
    end (* case *)
  
  let answer : any = apply red (r / exh)
  return (answer)
;
  
        
