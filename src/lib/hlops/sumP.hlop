(* sumP.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * To sum the elements of a rope "leafwise parallel."
 *)

#include "types.def"
#include "futures.def"
#include "ropes.def"

define @future1 (qt : [work_queue, thunk] / exh : exh) : future;
define @touch1 (qf : [work_queue, future] / exh : exh) : any;

define @sumP (qr : [work_queue, rope] / exh : exh) : ml_int =
  let q : work_queue = #0(qr)
  fun sumS (ns : list, acc : int / exh : exh) : int =
    case ns
      of NIL => return (acc)
       | CONS (mln : ml_int, ns : list) =>
           let n : int = #0(mln)
           let accX : int = I32Add (n, acc)
           let res : int = apply sumS (ns, accX / exh)
           return (res)            
    end
  fun sp (r : rope / exh : exh) : int = 
    case r
      of Leaf (len:int, data:list) => 
           let res : int = apply sumS (data, 0 / exh)
           return (res)
       | Cat (len:int, depth:int, r1:rope, r2:rope) =>
           fun th (u : unit / exh : exh) = apply sp (r2 / exh)
           let qt : [work_queue, thunk] = alloc (q, th)
           let f2 : future = @future1 (tup / exh)
           let s1 : int = apply sp (r1 / exh)
           let qf : [work_queue, future] = alloc (q, f2)
           let t2 : any = @touch1 (qf / exh)
           let s2 : int = (int)t2;
           let sum : int = I32Add (s1, s2)
           return sum
    end
  let r : rope = #1(qr)
  let res : int = apply sp (r / exh)
  let ml_res : ml_int = alloc (res)
  return (ml_res)
;
